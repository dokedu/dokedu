"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

input AddEventCompetenceInput {
  competenceId: ID!
  eventId: ID!
}

input AddUserToChatInput {
  chatId: ID!
  userId: ID!
}

type Chat {
  createdAt: Time!
  deleted: Boolean!
  deletedAt: Time
  id: ID!
  lastMessage: ChatMessage
  messages: [ChatMessage!]!
  name: String
  type: ChatType!
  unreadMessageCount: Int!
  userCount: Int!
  users: [User!]!
}

type ChatConnection {
  edges: [Chat]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChatMessage {
  chat: Chat!
  createdAt: Time!
  id: ID!
  isEdited: Boolean!
  isSeen: Boolean!
  message: String!
  user: User!
}

enum ChatType {
  AI
  CHANNEL
  GROUP
  PRIVATE
}

type ChatUser {
  chat: Chat!
  id: ID!
  user: User!
}

type Competence {
  color: String!
  competences(search: String, sort: CompetenceSort): [Competence]!
  createdAt: Time!
  grades: [Int!]!
  id: ID!
  name: String!
  parents: [Competence!]!
  sortOrder: Int!
  tendency(userId: ID!): CompetenceTendency
  type: CompetenceType!
  userCompetences(userId: ID): [UserCompetence]!
}

type CompetenceConnection {
  edges: [Competence]
  pageInfo: PageInfo!
  totalCount: Int!
}

input CompetenceFilterInput {
  parents: [ID]
  type: [CompetenceType]
  userId: ID
}

input CompetenceSort {
  field: CompetenceSortField!
  order: SortDirection!
}

enum CompetenceSortField {
  created_at
  name
  sort_order
}

type CompetenceTendency {
  countChildCompetences: Int!
  countLearnedCompetences: Int!
  tendency: Float!
}

enum CompetenceType {
  competence
  group
  subject
}

input CreateChatInput {
  name: String
}

input CreateCompetenceInput {
  name: String!
  parentId: ID!
}

input CreateEntryCompetenceInput {
  competenceId: ID!
  entryId: ID!
}

input CreateEntryEventInput {
  entryId: ID!
  eventId: ID!
}

input CreateEntryFileInput {
  entryId: ID!
  fileId: ID!
}

input CreateEntryTagInput {
  entryId: ID!
  tagId: ID!
}

input CreateEntryUserInput {
  entryId: ID!
  userId: ID!
}

input CreateEventInput {
  body: String
  endsAt: String
  image: Upload
  recurrence: [String]
  startsAt: String
  title: String!
}

input CreateFileInput {
  folderId: ID
  name: String!
  type: FileType!
  upload: Upload
}

type CreateFilePayload {
  file: File!
}

input CreateFilePermissionInput {
  fileId: ID!
  permission: FilePermissionRole!
  userId: ID!
}

type CreateFilePermissionPayload {
  filePermission: FilePermission!
}

input CreateReportInput {
  allUsers: Boolean
  filterTags: [ID!]!
  format: ReportFormat!
  from: Time!
  kind: ReportKind!
  studentUser: ID
  to: Time!
}

input CreateStudentInput {
  birthday: Time
  emoji: String
  firstName: String!
  grade: Int!
  joinedAt: Time
  lastName: String!
  leftAt: Time
}

input CreateTagInput {
  color: String!
  name: String!
}

input CreateUserCompetenceInput {
  competenceId: ID!
  level: Int!
  userId: ID!
}

input CreateUserInput {
  birthday: Time
  email: String!
  firstName: String!
  joinedAt: Time
  lastName: String!
  leftAt: Time
  role: UserRole!
}

input DeleteChatInput {
  id: ID!
}

input DeleteEntryCompetenceInput {
  competenceId: ID!
  entryId: ID!
}

input DeleteEntryEventInput {
  entryId: ID!
  eventId: ID!
}

input DeleteEntryFileInput {
  entryId: ID!
  fileId: ID!
}

input DeleteEntryTagInput {
  entryId: ID!
  tagId: ID!
}

input DeleteEntryUserInput {
  entryId: ID!
  userId: ID!
}

input DeleteFileInput {
  id: ID!
}

type DeleteFilePayload {
  file: File!
}

input DeleteFilePermissionInput {
  id: ID!
}

type DeleteFilePermissionPayload {
  filePermission: FilePermission!
}

input EditChatMessageInput {
  id: ID!
  message: String!
}

type Entry {
  body: String!
  createdAt: Time!
  date: String!
  deletedAt: Time
  events: [Event!]!
  files: [File!]!
  id: ID!
  subjects: [Competence!]!
  tags: [Tag!]!
  user: User!
  userCompetences: [UserCompetence!]!
  users: [User!]!
}

type EntryConnection {
  edges: [Entry!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input EntryFilterInput {
  authors: [ID]
  competences: [ID]
  deleted: Boolean
  from: Time
  tags: [ID]
  to: Time
  users: [ID]
}

enum EntrySortBy {
  createdAt_ASC
  createdAt_DESC
  date_ASC
  date_DESC
}

type Event {
  body: String
  competences: [Competence!]!
  createdAt: Time!
  deletedAt: Time
  endsAt: Time!
  id: ID!
  image: File
  recurrence: [String]
  startsAt: Time!
  title: String!
}

type EventConnection {
  edges: [Event]
  pageInfo: PageInfo!
  totalCount: Int!
}

input EventFilterInput {
  deleted: Boolean
  from: Time
  to: Time
}

enum EventOrderBy {
  endsAt_ASC
  endsAt_DESC
  startsAt_ASC
  startsAt_DESC
}

input ExportEventsInput {
  deleted: Boolean!
  from: String!
  to: String!
}

type ExportEventsPayload {
  body: String!
  endsAt: String!
  id: ID!
  startsAt: String!
  subjects: String!
  title: String!
}

type File {
  children: [File!]!
  createdAt: Time!
  deletedAt: Time
  id: ID!
  mime: String!
  name: String!
  parent: File
  parentsRecursive: [File!]!
  permissions: [FilePermission!]!
  size: Int!
  type: FileType!
}

type FileConnection {
  edges: [File!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input FileFilterInput {
  deleted: Boolean = false
  limit: Int
  offset: Int
  parentId: ID
  search: String
}

type FilePermission {
  displayName: String!
  emailAddress: String
  file: File!
  id: ID!
  inherited: Boolean!
  role: FilePermissionRole!
  type: FilePermissionType!
}

enum FilePermissionRole {
  MANAGER
  VIEWER
}

enum FilePermissionType {
  ANYONE
  DOMAIN
  GROUP
  USER
}

enum FileType {
  BLOB
  FOLDER
}

input ForgotPasswordInput {
  email: String!
}

type ForgotPasswordPayload {
  success: Boolean!
}

enum ImportStudentsError {
  DATA_WRONG
  FORMAT_WRONG
  GRADE_WRONG
  HEADER_WRONG
  PERMISSION_DENIED
}

input ImportStudentsInput {
  file: Upload!
}

type ImportStudentsPayload {
  errors: [ImportStudentsError!]!
  usersCreated: Int!
  usersExisted: Int!
}

type InviteDetailsPayload {
  email: String!
  firstName: String!
  lastName: String!
}

type Mutation {
  acceptInvite(input: SignUpInput!, token: String!): SignInPayload!
  addUserToChat(input: AddUserToChatInput!): ChatUser!
  archiveEntry(id: ID!): Entry!
  archiveEvent(id: ID!): Event!
  archiveTag(id: ID!): Tag!
  archiveUser(id: ID!): User!
  archiveUserCompetence(id: ID!): UserCompetence!
  createChat(input: CreateChatInput!): Chat!
  createCompetence(input: CreateCompetenceInput!): Competence!
  createEntry: Entry!
  createEntryCompetence(input: CreateEntryCompetenceInput!): Entry!
  createEntryEvent(input: CreateEntryEventInput!): Entry!
  createEntryFile(input: CreateEntryFileInput!): Entry!
  createEntryTag(input: CreateEntryTagInput!): Entry!
  createEntryUser(input: CreateEntryUserInput!): Entry!
  createEvent(input: CreateEventInput!): Event!
  createFile(input: CreateFileInput!): CreateFilePayload!
  createFilePermission(input: CreateFilePermissionInput!): CreateFilePermissionPayload!
  createPrivatChat(userId: ID!): Chat!
  createReport(input: CreateReportInput!): [Report]!
  createStudent(input: CreateStudentInput!): User!
  createTag(input: CreateTagInput!): Tag!
  createUser(input: CreateUserInput!): User!
  createUserCompetence(input: CreateUserCompetenceInput!): UserCompetence!
  deleteChat(input: DeleteChatInput!): Chat!
  deleteEntryCompetence(input: DeleteEntryCompetenceInput!): Entry!
  deleteEntryEvent(input: DeleteEntryEventInput!): Entry!
  deleteEntryFile(input: DeleteEntryFileInput!): Entry!
  deleteEntryTag(input: DeleteEntryTagInput!): Entry!
  deleteEntryUser(input: DeleteEntryUserInput!): Entry!
  deleteFile(input: DeleteFileInput!): DeleteFilePayload!
  deleteFilePermission(input: DeleteFilePermissionInput!): DeleteFilePermissionPayload!
  editChatMessage(input: EditChatMessageInput!): ChatMessage!
  forgotPassword(input: ForgotPasswordInput!): Boolean!
  importStudents(input: ImportStudentsInput!): ImportStudentsPayload!
  markMessageAsRead(messageId: ID!): ChatMessage!
  removeFileFromEntry(entryId: ID!, fileId: ID!): File!
  removeUserFromChat(input: RemoveUserFromChatInput!): ChatUser!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!
  sendMessage(input: SendMessageInput!): ChatMessage!
  sendUserInvite(id: ID!): Boolean!
  signIn(input: SignInInput!): SignInPayload!
  signOut: Boolean!
  toggleEventCompetence(input: AddEventCompetenceInput!): Event!
  updateChat(input: UpdateChatInput!): Chat!
  updateCompetence(input: UpdateCompetenceInput!): Competence!
  updateCompetenceSorting(input: UpdateCompetenceSortingInput!): [Competence]!
  updateEntry(input: UpdateEntryInput!): Entry!
  updateEntryUserCompetenceLevel(input: UpdateEntryUserCompetenceLevel!): Entry!
  updateEvent(input: UpdateEventInput!): Event!
  updateFile(input: UpdateFileInput!): UpdateFilePayload!
  updateFilePermission(input: UpdateFilePermissionInput!): UpdateFilePermissionPayload!
  updateOrganisation(input: UpdateOrganisationInput!): Organisation!
  updatePassword(newPassword: String!, oldPassword: String!): Boolean!
  updateTag(id: ID!, input: CreateTagInput!): Tag!
  updateUser(input: UpdateUserInput!): User!
  updateUserAttendance(input: UpdateUserAttendanceInput!): UserAttendance!
  updateUserLanguage(language: UserLanguage!): User!
  uploadFileToEntry(entryId: ID!, file: Upload!): Entry!
}

type Organisation {
  applications: [OrganisationApplication!]!
  id: ID!
  legalName: String!
  name: String!
  owner: User!
  phone: String
  website: String
}

enum OrganisationApplication {
  ADMIN
  CHAT
  DRIVE
  EMAIL
  RECORD
  SCHOOL
}

type PageInfo {
  currentPage: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

type Query {
  chat(id: ID!): Chat!
  chats(limit: Int, offset: Int): ChatConnection!
  competence(id: ID!): Competence!
  competences(filter: CompetenceFilterInput, limit: Int, offset: Int, search: String, sort: CompetenceSort): CompetenceConnection!
  entries(filter: EntryFilterInput, limit: Int, offset: Int, search: String, sortBy: EntrySortBy): EntryConnection!
  entry(id: ID!): Entry!
  event(id: ID!): Event!
  events(filter: EventFilterInput, limit: Int, offset: Int, order: EventOrderBy, search: String): EventConnection!
  exportEvents(input: ExportEventsInput!): [ExportEventsPayload]!
  file(id: ID!): File!
  files(input: FileFilterInput): FileConnection!
  inviteDetails(token: String!): InviteDetailsPayload!
  me: User!
  myDrive(input: FileFilterInput): FileConnection!
  organisation: Organisation
  report(id: ID!): Report!
  reports(limit: Int, offset: Int): ReportConnection!
  sharedDrives(input: FileFilterInput): FileConnection!
  tag(id: ID!): Tag!
  tags(limit: Int, offset: Int, search: String): TagConnection!
  trash(input: FileFilterInput): FileConnection!
  user(id: ID!): User!
  userAttendances(date: Time!): [UserAttendance!]!
  userStudent(id: ID!): UserStudent!
  userStudents(limit: Int, offset: Int): UserStudentConnection!
  users(filter: UserFilterInput, limit: Int, offset: Int, search: String): UserConnection!
}

input RemoveUserFromChatInput {
  chatId: ID!
  userId: ID!
}

type Report {
  createdAt: Time!
  deletedAt: Time
  file: File
  filterTags: [ID!]!
  format: ReportFormat!
  from: Time!
  id: ID!
  kind: ReportKind!
  meta: String!
  status: ReportStatus!
  studentUser: User!
  to: Time!
  user: User!
}

type ReportConnection {
  edges: [Report]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ReportFormat {
  docx
  pdf
}

enum ReportKind {
  all_entries
  competences
  entries
  learned_competences
  subjects
}

enum ReportStatus {
  done
  error
  pending
  processing
}

input ResetPasswordInput {
  password: String!
  token: String
}

type ResetPasswordPayload {
  organisation: Organisation!
  token: String!
  user: User!
}

input SendMessageInput {
  chatId: ID!
  message: String!
}

input SignInInput {
  email: String!
  password: String!
}

type SignInPayload {
  organisation: Organisation!
  token: String!
  user: User!
}

input SignUpInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

input SortCompetenceInput {
  id: ID!
  sortOrder: Int!
}

enum SortDirection {
  asc
  desc
}

type Subscription {
  messageAdded: ChatMessage!
  reportCreatedOrUpdated: Report!
}

type Tag {
  color: String!
  createdAt: Time!
  deletedAt: Time
  id: ID!
  name: String!
}

type TagConnection {
  edges: [Tag]
  pageInfo: PageInfo!
  totalCount: Int!
}

scalar Time

input UpdateChatInput {
  id: ID!
  name: String
}

input UpdateCompetenceInput {
  color: String
  id: ID!
}

input UpdateCompetenceSortingInput {
  competences: [SortCompetenceInput!]!
}

input UpdateEntryInput {
  body: String
  date: String
  id: ID!
}

input UpdateEntryUserCompetenceLevel {
  competenceId: ID!
  entryId: ID!
  level: Int!
}

input UpdateEventInput {
  body: String
  endsAt: String
  id: ID!
  image: Upload
  recurrence: [String]
  startsAt: String
  title: String
}

input UpdateFileInput {
  id: ID!
  name: String
  parentId: ID
}

type UpdateFilePayload {
  file: File!
}

input UpdateFilePermissionInput {
  id: ID!
  permission: FilePermissionRole!
}

type UpdateFilePermissionPayload {
  filePermission: FilePermission!
}

input UpdateOrganisationInput {
  id: ID!
  legalName: String
  name: String
  phone: String
  website: String
}

input UpdateUserAttendanceInput {
  date: Time!
  state: UserAttendanceState!
  userId: ID!
}

input UpdateUserCompetenceInput {
  competenceId: ID!
  level: Int!
  userId: ID!
}

input UpdateUserInput {
  birthday: Time
  email: String
  emoji: String
  firstName: String!
  grade: Int
  id: ID!
  joinedAt: Time
  lastName: String!
  leftAt: Time
  missedHours: Int
  missedHoursExcused: Int
}

scalar Upload

type User {
  createdAt: Time!
  deletedAt: Time
  email: String
  firstName: String!
  id: ID!
  inviteAccepted: Boolean!
  language: UserLanguage
  lastName: String!
  lastSeenAt: Time
  organisationId: ID!
  role: UserRole!
  student: UserStudent
}

type UserAttendance {
  date: Time!
  id: ID!
  state: UserAttendanceState!
  user: User!
}

enum UserAttendanceState {
  ABSENT
  LATE
  PRESENT
  SICK
  UNKNOWN
}

type UserCompetence {
  competence: Competence!
  createdAt: Time!
  createdBy: User
  entry: Entry
  id: ID!
  level: Int!
  user: User!
}

type UserCompetenceConnection {
  edges: [UserCompetence]
  pageInfo: PageInfo!
  totalCount: Int!
}

input UserCompetenceFilterInput {
  competenceID: ID
  userID: ID
}

type UserConnection {
  edges: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

input UserFilterInput {
  orderBy: UserOrderBy
  role: [UserRole]
  showDeleted: Boolean
}

enum UserLanguage {
  de
  en
}

enum UserOrderBy {
  firstNameAsc
  firstNameDesc
  lastNameAsc
  lastNameDesc
}

enum UserRole {
  admin
  educator
  owner
  parent
  student
  teacher
}

type UserStudent {
  birthday: Time
  comments: String
  competencesCount: Int!
  createdAt: Time!
  deletedAt: Time
  emoji: String
  entriesCount: Int!
  eventsCount: Int!
  grade: Int!
  id: ID!
  joinedAt: Time
  leftAt: Time
  missedHours: Int!
  missedHoursExcused: Int!
  nationality: String
  user: User!
}

type UserStudentConnection {
  edges: [UserStudent]
  pageInfo: PageInfo!
  totalCount: Int!
}