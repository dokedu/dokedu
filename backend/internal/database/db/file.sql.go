// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: file.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (name, mime_type, file_type, bucket_id, parent_id, organisation_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
`

type CreateFileParams struct {
	Name           string      `db:"name"`
	MimeType       pgtype.Text `db:"mime_type"`
	FileType       FileType    `db:"file_type"`
	BucketID       string      `db:"bucket_id"`
	ParentID       pgtype.Text `db:"parent_id"`
	OrganisationID string      `db:"organisation_id"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Name,
		arg.MimeType,
		arg.FileType,
		arg.BucketID,
		arg.ParentID,
		arg.OrganisationID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FileType,
		&i.MimeType,
		&i.Size,
		&i.BucketID,
		&i.ParentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :one
UPDATE files
SET deleted_at = now()
WHERE id = $1 AND organisation_id = $2
RETURNING id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
`

type DeleteFileParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) (File, error) {
	row := q.db.QueryRow(ctx, deleteFile, arg.ID, arg.OrganisationID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FileType,
		&i.MimeType,
		&i.Size,
		&i.BucketID,
		&i.ParentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const fileById = `-- name: FileById :one
SELECT id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
FROM files
WHERE id = $1 AND organisation_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type FileByIdParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) FileById(ctx context.Context, arg FileByIdParams) (File, error) {
	row := q.db.QueryRow(ctx, fileById, arg.ID, arg.OrganisationID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FileType,
		&i.MimeType,
		&i.Size,
		&i.BucketID,
		&i.ParentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const fileListByBucketId = `-- name: FileListByBucketId :many
SELECT id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
FROM files
WHERE bucket_id = $1 AND organisation_id = $2 AND deleted_at IS NULL
ORDER BY name DESC
`

type FileListByBucketIdParams struct {
	BucketID       string `db:"bucket_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) FileListByBucketId(ctx context.Context, arg FileListByBucketIdParams) ([]File, error) {
	rows, err := q.db.Query(ctx, fileListByBucketId, arg.BucketID, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FileType,
			&i.MimeType,
			&i.Size,
			&i.BucketID,
			&i.ParentID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fileListByEntryFileByEntryId = `-- name: FileListByEntryFileByEntryId :many
SELECT files.id, files.name, files.file_type, files.mime_type, files.size, files.bucket_id, files.parent_id, files.organisation_id, files.created_at, files.deleted_at
FROM files
         JOIN public.entry_files eu ON files.id = eu.file_id
         JOIN public.entries e ON eu.entry_id = e.id
WHERE eu.deleted_at IS NULL AND e.id = $1
  AND files.organisation_id = $2 AND files.deleted_at IS NULL
ORDER BY files.name
`

type FileListByEntryFileByEntryIdParams struct {
	EntryID        string `db:"entry_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) FileListByEntryFileByEntryId(ctx context.Context, arg FileListByEntryFileByEntryIdParams) ([]File, error) {
	rows, err := q.db.Query(ctx, fileListByEntryFileByEntryId, arg.EntryID, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FileType,
			&i.MimeType,
			&i.Size,
			&i.BucketID,
			&i.ParentID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fileListByParentId = `-- name: FileListByParentId :many
SELECT id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
FROM files
WHERE parent_id = $1 AND organisation_id = $2 AND deleted_at IS NULL
ORDER BY name
`

type FileListByParentIdParams struct {
	ParentID       pgtype.Text `db:"parent_id"`
	OrganisationID string      `db:"organisation_id"`
}

func (q *Queries) FileListByParentId(ctx context.Context, arg FileListByParentIdParams) ([]File, error) {
	rows, err := q.db.Query(ctx, fileListByParentId, arg.ParentID, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FileType,
			&i.MimeType,
			&i.Size,
			&i.BucketID,
			&i.ParentID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fileParentList = `-- name: FileParentList :many
WITH RECURSIVE file_parents AS (
    SELECT id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at, 1 AS level
    FROM files
    WHERE files.id = $1 AND files.organisation_id = $2 AND deleted_at IS NULL

    UNION ALL

    SELECT f.id, f.name, f.file_type, f.mime_type, f.size, f.bucket_id, f.parent_id, f.organisation_id, f.created_at, f.deleted_at, fp.level + 1
    FROM files f
             JOIN file_parents fp ON f.id = fp.parent_id
    WHERE f.organisation_id = $2 AND deleted_at IS NULL
)
SELECT file_parents.id, file_parents.name, file_parents.file_type, file_parents.mime_type, file_parents.size, file_parents.bucket_id, file_parents.parent_id, file_parents.organisation_id, file_parents.created_at, file_parents.deleted_at, file_parents.level
FROM file_parents
ORDER BY level DESC
`

type FileParentListParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

type FileParentListRow struct {
	ID             string             `db:"id"`
	Name           string             `db:"name"`
	FileType       FileType           `db:"file_type"`
	MimeType       pgtype.Text        `db:"mime_type"`
	Size           int64              `db:"size"`
	BucketID       string             `db:"bucket_id"`
	ParentID       pgtype.Text        `db:"parent_id"`
	OrganisationID string             `db:"organisation_id"`
	CreatedAt      time.Time          `db:"created_at"`
	DeletedAt      pgtype.Timestamptz `db:"deleted_at"`
	Level          int32              `db:"level"`
}

// TODO: fix this query and make it work properly
func (q *Queries) FileParentList(ctx context.Context, arg FileParentListParams) ([]FileParentListRow, error) {
	rows, err := q.db.Query(ctx, fileParentList, arg.ID, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileParentListRow
	for rows.Next() {
		var i FileParentListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FileType,
			&i.MimeType,
			&i.Size,
			&i.BucketID,
			&i.ParentID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileName = `-- name: UpdateFileName :one
UPDATE files
SET name = $1
WHERE id = $2 AND organisation_id = $3
RETURNING id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
`

type UpdateFileNameParams struct {
	Name           string `db:"name"`
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) UpdateFileName(ctx context.Context, arg UpdateFileNameParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFileName, arg.Name, arg.ID, arg.OrganisationID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FileType,
		&i.MimeType,
		&i.Size,
		&i.BucketID,
		&i.ParentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateFileParentId = `-- name: UpdateFileParentId :one
UPDATE files
SET parent_id = $1
WHERE id = $2 AND organisation_id = $3
RETURNING id, name, file_type, mime_type, size, bucket_id, parent_id, organisation_id, created_at, deleted_at
`

type UpdateFileParentIdParams struct {
	ParentID       pgtype.Text `db:"parent_id"`
	ID             string      `db:"id"`
	OrganisationID string      `db:"organisation_id"`
}

func (q *Queries) UpdateFileParentId(ctx context.Context, arg UpdateFileParentIdParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFileParentId, arg.ParentID, arg.ID, arg.OrganisationID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FileType,
		&i.MimeType,
		&i.Size,
		&i.BucketID,
		&i.ParentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}
