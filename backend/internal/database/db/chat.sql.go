// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: chat.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const botUserByChatId = `-- name: BotUserByChatId :one
SELECT users.id, role, users.organisation_id, first_name, last_name, email, password, recovery_token, recovery_sent_at, avatar_file_id, created_at, deleted_at, language, sex, cu.id, chat_id, user_id, cu.organisation_id
FROM users
         INNER JOIN public.chat_users cu ON users.id = cu.user_id
WHERE cu.id = $1
  AND users.role = 'bot'::user_role
  AND users.organisation_id = $2
LIMIT 1
`

type BotUserByChatIdParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

type BotUserByChatIdRow struct {
	ID               string             `db:"id"`
	Role             UserRole           `db:"role"`
	OrganisationID   string             `db:"organisation_id"`
	FirstName        string             `db:"first_name"`
	LastName         string             `db:"last_name"`
	Email            pgtype.Text        `db:"email"`
	Password         pgtype.Text        `db:"password"`
	RecoveryToken    pgtype.Text        `db:"recovery_token"`
	RecoverySentAt   pgtype.Timestamptz `db:"recovery_sent_at"`
	AvatarFileID     pgtype.Text        `db:"avatar_file_id"`
	CreatedAt        time.Time          `db:"created_at"`
	DeletedAt        pgtype.Timestamptz `db:"deleted_at"`
	Language         NullUserLang       `db:"language"`
	Sex              pgtype.Text        `db:"sex"`
	ID_2             string             `db:"id_2"`
	ChatID           string             `db:"chat_id"`
	UserID           string             `db:"user_id"`
	OrganisationID_2 string             `db:"organisation_id_2"`
}

func (q *Queries) BotUserByChatId(ctx context.Context, arg BotUserByChatIdParams) (BotUserByChatIdRow, error) {
	row := q.db.QueryRow(ctx, botUserByChatId, arg.ID, arg.OrganisationID)
	var i BotUserByChatIdRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.OrganisationID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.RecoveryToken,
		&i.RecoverySentAt,
		&i.AvatarFileID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Language,
		&i.Sex,
		&i.ID_2,
		&i.ChatID,
		&i.UserID,
		&i.OrganisationID_2,
	)
	return i, err
}

const chatById = `-- name: ChatById :one
SELECT id, name, organisation_id, updated_at, created_at, deleted_at, type
FROM chats
WHERE id = $1
  AND organisation_id = $2
LIMIT 1
`

type ChatByIdParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) ChatById(ctx context.Context, arg ChatByIdParams) (Chat, error) {
	row := q.db.QueryRow(ctx, chatById, arg.ID, arg.OrganisationID)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const chatByIdWithUser = `-- name: ChatByIdWithUser :one
SELECT chat.id, chat.name, chat.organisation_id, chat.updated_at, chat.created_at, chat.deleted_at, chat.type
FROM chats chat
         INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = $1
WHERE chat.id = $2
  AND chat.organisation_id = $3
LIMIT 1
`

type ChatByIdWithUserParams struct {
	UserID         string `db:"user_id"`
	ChatID         string `db:"chat_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) ChatByIdWithUser(ctx context.Context, arg ChatByIdWithUserParams) (Chat, error) {
	row := q.db.QueryRow(ctx, chatByIdWithUser, arg.UserID, arg.ChatID, arg.OrganisationID)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const chatByIdWithoutOrg = `-- name: ChatByIdWithoutOrg :one
SELECT id, name, organisation_id, updated_at, created_at, deleted_at, type
FROM chats
WHERE id = $1
LIMIT 1
`

func (q *Queries) ChatByIdWithoutOrg(ctx context.Context, id string) (Chat, error) {
	row := q.db.QueryRow(ctx, chatByIdWithoutOrg, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const chatListWithUser = `-- name: ChatListWithUser :many
SELECT chat.id, chat.name, chat.organisation_id, chat.updated_at, chat.created_at, chat.deleted_at, chat.type,
       MAX(cm.created_at) AS last_message_at,
       COUNT(*) OVER ()   AS total_count
FROM chats AS chat
         LEFT JOIN chat_users ON chat_users.chat_id = chat.id
         LEFT JOIN chat_messages cm ON cm.chat_id = chat.id
WHERE chat_users.user_id = $1
  AND chat.organisation_id = $2
  AND chat.deleted_at IS NULL
GROUP BY chat.id
ORDER BY CASE WHEN MAX(cm.created_at) IS NULL THEN 1 ELSE 0 END,
         last_message_at DESC
LIMIT $4
OFFSET $3
`

type ChatListWithUserParams struct {
	UserID         string `db:"user_id"`
	OrganisationID string `db:"organisation_id"`
	PageOffset     int32  `db:"page_offset"`
	PageLimit      int32  `db:"page_limit"`
}

type ChatListWithUserRow struct {
	ID             string             `db:"id"`
	Name           pgtype.Text        `db:"name"`
	OrganisationID string             `db:"organisation_id"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at"`
	CreatedAt      time.Time          `db:"created_at"`
	DeletedAt      pgtype.Timestamptz `db:"deleted_at"`
	Type           NullChatType       `db:"type"`
	LastMessageAt  interface{}        `db:"last_message_at"`
	TotalCount     int64              `db:"total_count"`
}

func (q *Queries) ChatListWithUser(ctx context.Context, arg ChatListWithUserParams) ([]ChatListWithUserRow, error) {
	rows, err := q.db.Query(ctx, chatListWithUser,
		arg.UserID,
		arg.OrganisationID,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatListWithUserRow
	for rows.Next() {
		var i ChatListWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganisationID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Type,
			&i.LastMessageAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const chatMessageById = `-- name: ChatMessageById :one
SELECT id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
FROM chat_messages
WHERE id = $1
LIMIT 1
`

func (q *Queries) ChatMessageById(ctx context.Context, id string) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, chatMessageById, id)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const chatMessageListByChatId = `-- name: ChatMessageListByChatId :many
SELECT id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
FROM chat_messages
WHERE chat_id = $1
  AND organisation_id = $2
`

type ChatMessageListByChatIdParams struct {
	ChatID         string `db:"chat_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) ChatMessageListByChatId(ctx context.Context, arg ChatMessageListByChatIdParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, chatMessageListByChatId, arg.ChatID, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.UserID,
			&i.Message,
			&i.OrganisationID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const chatMessagesByChatIdWithoutOrg = `-- name: ChatMessagesByChatIdWithoutOrg :many
SELECT id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
FROM chat_messages
WHERE chat_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ChatMessagesByChatIdWithoutOrg(ctx context.Context, chatID string) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, chatMessagesByChatIdWithoutOrg, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.UserID,
			&i.Message,
			&i.OrganisationID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const chatNameWithAuthByChatId = `-- name: ChatNameWithAuthByChatId :one
SELECT users.id, users.first_name, users.last_name
FROM users
         LEFT JOIN chat_users cu ON users.id = cu.user_id AND cu.chat_id = $1
WHERE users.id = $2
  AND users.organisation_id = $3
LIMIT 1
`

type ChatNameWithAuthByChatIdParams struct {
	ChatID         string `db:"chat_id"`
	UserID         string `db:"user_id"`
	OrganisationID string `db:"organisation_id"`
}

type ChatNameWithAuthByChatIdRow struct {
	ID        string `db:"id"`
	FirstName string `db:"first_name"`
	LastName  string `db:"last_name"`
}

func (q *Queries) ChatNameWithAuthByChatId(ctx context.Context, arg ChatNameWithAuthByChatIdParams) (ChatNameWithAuthByChatIdRow, error) {
	row := q.db.QueryRow(ctx, chatNameWithAuthByChatId, arg.ChatID, arg.UserID, arg.OrganisationID)
	var i ChatNameWithAuthByChatIdRow
	err := row.Scan(&i.ID, &i.FirstName, &i.LastName)
	return i, err
}

const chatUserByChatId = `-- name: ChatUserByChatId :many
SELECT id, chat_id, user_id, organisation_id
FROM chat_users
WHERE chat_id = $1
`

func (q *Queries) ChatUserByChatId(ctx context.Context, chatID string) ([]ChatUser, error) {
	rows, err := q.db.Query(ctx, chatUserByChatId, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatUser
	for rows.Next() {
		var i ChatUser
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.UserID,
			&i.OrganisationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats (name, type, organisation_id)
VALUES ($1, $2, $3)
RETURNING id, name, organisation_id, updated_at, created_at, deleted_at, type
`

type CreateChatParams struct {
	Name           pgtype.Text  `db:"name"`
	Type           NullChatType `db:"type"`
	OrganisationID string       `db:"organisation_id"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat, arg.Name, arg.Type, arg.OrganisationID)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (chat_id, user_id, message, organisation_id)
VALUES ($1, $2, $3, $4)
RETURNING id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
`

type CreateChatMessageParams struct {
	ChatID         string `db:"chat_id"`
	UserID         string `db:"user_id"`
	Message        string `db:"message"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.UserID,
		arg.Message,
		arg.OrganisationID,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createChatMessageByUser = `-- name: CreateChatMessageByUser :one
WITH valid_user AS (SELECT 1
                    FROM chat_users
                    WHERE chat_id = $1
                      AND user_id = $2
                      AND organisation_id = $4
                    LIMIT 1)
INSERT
INTO chat_messages (chat_id, user_id, message, organisation_id)
SELECT $1, $2, $3, $4
FROM valid_user
RETURNING id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
`

type CreateChatMessageByUserParams struct {
	ChatID         string `db:"chat_id"`
	UserID         string `db:"user_id"`
	Message        string `db:"message"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) CreateChatMessageByUser(ctx context.Context, arg CreateChatMessageByUserParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessageByUser,
		arg.ChatID,
		arg.UserID,
		arg.Message,
		arg.OrganisationID,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createChatUser = `-- name: CreateChatUser :one
INSERT INTO chat_users (chat_id, user_id, organisation_id)
VALUES ($1, $2, $3)
RETURNING id, chat_id, user_id, organisation_id
`

type CreateChatUserParams struct {
	ChatID         string `db:"chat_id"`
	UserID         string `db:"user_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) CreateChatUser(ctx context.Context, arg CreateChatUserParams) (ChatUser, error) {
	row := q.db.QueryRow(ctx, createChatUser, arg.ChatID, arg.UserID, arg.OrganisationID)
	var i ChatUser
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.OrganisationID,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :one
UPDATE chats
SET deleted_at = NOW()
WHERE chats.id = $1
  AND chats.organisation_id = $2
  AND chats.id IN (SELECT chat_id
                   FROM chat_users
                   WHERE chat_users.user_id = $3
                     AND chat_users.organisation_id = $2)
RETURNING id, name, organisation_id, updated_at, created_at, deleted_at, type
`

type DeleteChatParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
	UserID         string `db:"user_id"`
}

func (q *Queries) DeleteChat(ctx context.Context, arg DeleteChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, deleteChat, arg.ID, arg.OrganisationID, arg.UserID)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const deleteChatUser = `-- name: DeleteChatUser :one
DELETE
FROM chat_users
WHERE chat_users.chat_id = $1
  AND chat_users.user_id = $2
  AND chat_users.organisation_id = $3
  AND EXISTS (SELECT 1
              FROM chat_users AS cu
              WHERE cu.chat_id = $1
                AND cu.user_id = $4
                AND cu.organisation_id = $3)
RETURNING id, chat_id, user_id, organisation_id
`

type DeleteChatUserParams struct {
	ChatID         string `db:"chat_id"`
	UserID         string `db:"user_id"`
	OrganisationID string `db:"organisation_id"`
	CurrentUserID  string `db:"current_user_id"`
}

func (q *Queries) DeleteChatUser(ctx context.Context, arg DeleteChatUserParams) (ChatUser, error) {
	row := q.db.QueryRow(ctx, deleteChatUser,
		arg.ChatID,
		arg.UserID,
		arg.OrganisationID,
		arg.CurrentUserID,
	)
	var i ChatUser
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.OrganisationID,
	)
	return i, err
}

const existingChatBetweenTwoUsers = `-- name: ExistingChatBetweenTwoUsers :one
SELECT chat.id, chat.name, chat.organisation_id, chat.updated_at, chat.created_at, chat.deleted_at, chat.type
FROM chats chat
         INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = $1
         INNER JOIN chat_users AS chat_users2 ON chat_users2.chat_id = chat.id AND chat_users2.user_id = $2
WHERE chat.type = $3
  AND chat.organisation_id = $4
`

type ExistingChatBetweenTwoUsersParams struct {
	UserID         string       `db:"user_id"`
	OtherUserID    string       `db:"other_user_id"`
	ChatType       NullChatType `db:"chat_type"`
	OrganisationID string       `db:"organisation_id"`
}

func (q *Queries) ExistingChatBetweenTwoUsers(ctx context.Context, arg ExistingChatBetweenTwoUsersParams) (Chat, error) {
	row := q.db.QueryRow(ctx, existingChatBetweenTwoUsers,
		arg.UserID,
		arg.OtherUserID,
		arg.ChatType,
		arg.OrganisationID,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const lastChatMessage = `-- name: LastChatMessage :one
SELECT id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
FROM chat_messages
WHERE chat_id = $1
  AND organisation_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type LastChatMessageParams struct {
	ChatID         string `db:"chat_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) LastChatMessage(ctx context.Context, arg LastChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, lastChatMessage, arg.ChatID, arg.OrganisationID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const markChatMessageAsRead = `-- name: MarkChatMessageAsRead :one
WITH valid_user AS (SELECT chat_users.chat_id
                    FROM chat_users
                             JOIN chat_messages ON chat_messages.chat_id = chat_users.chat_id
                    WHERE chat_messages.id = $1
                      AND chat_users.user_id = $2
                      AND chat_users.organisation_id = $3
                    LIMIT 1)
INSERT
INTO chat_message_views (chat_message_id, user_id, chat_id, organisation_id)
SELECT $1, $2, valid_user.chat_id, $3
FROM valid_user
ON CONFLICT DO NOTHING
RETURNING id, user_id, chat_id, chat_message_id, organisation_id, created_at
`

type MarkChatMessageAsReadParams struct {
	ChatMessageID  string `db:"chat_message_id"`
	UserID         string `db:"user_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) MarkChatMessageAsRead(ctx context.Context, arg MarkChatMessageAsReadParams) (ChatMessageView, error) {
	row := q.db.QueryRow(ctx, markChatMessageAsRead, arg.ChatMessageID, arg.UserID, arg.OrganisationID)
	var i ChatMessageView
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChatID,
		&i.ChatMessageID,
		&i.OrganisationID,
		&i.CreatedAt,
	)
	return i, err
}

const unreadMessageCount = `-- name: UnreadMessageCount :one
SELECT COUNT(*)
FROM chat_messages
         LEFT JOIN chat_message_views cmv ON chat_messages.id = cmv.chat_message_id
WHERE chat_messages.chat_id = $1
  AND chat_messages.organisation_id = $2
  AND cmv.user_id = $3
`

type UnreadMessageCountParams struct {
	ChatID         string `db:"chat_id"`
	OrganisationID string `db:"organisation_id"`
	UserID         string `db:"user_id"`
}

func (q *Queries) UnreadMessageCount(ctx context.Context, arg UnreadMessageCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, unreadMessageCount, arg.ChatID, arg.OrganisationID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateChatMessageByUser = `-- name: UpdateChatMessageByUser :one
UPDATE chat_messages
SET message = $1
FROM chat_users
WHERE chat_messages.id = $2
  AND chat_messages.user_id = $3
  AND chat_users.user_id = chat_messages.user_id
  AND chat_users.organisation_id = $4
  AND chat_users.chat_id = chat_messages.chat_id
RETURNING chat_messages.id, chat_messages.chat_id, chat_messages.user_id, chat_messages.message, chat_messages.organisation_id, chat_messages.updated_at, chat_messages.created_at, chat_messages.deleted_at
`

type UpdateChatMessageByUserParams struct {
	Message        string `db:"message"`
	MessageID      string `db:"message_id"`
	UserID         string `db:"user_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) UpdateChatMessageByUser(ctx context.Context, arg UpdateChatMessageByUserParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessageByUser,
		arg.Message,
		arg.MessageID,
		arg.UserID,
		arg.OrganisationID,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateChatMessageMessageWithoutOrg = `-- name: UpdateChatMessageMessageWithoutOrg :one
UPDATE chat_messages
SET message = $2
WHERE id = $1
RETURNING id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
`

type UpdateChatMessageMessageWithoutOrgParams struct {
	ID      string `db:"id"`
	Message string `db:"message"`
}

func (q *Queries) UpdateChatMessageMessageWithoutOrg(ctx context.Context, arg UpdateChatMessageMessageWithoutOrgParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessageMessageWithoutOrg, arg.ID, arg.Message)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateChatName = `-- name: UpdateChatName :one
UPDATE chats
SET name = $1
FROM chat_users
WHERE chats.id = $2
  AND chat_users.user_id = $3
  AND chat_users.organisation_id = $4
  AND chat_users.chat_id = chats.id
RETURNING chats.id, chats.name, chats.organisation_id, chats.updated_at, chats.created_at, chats.deleted_at, chats.type
`

type UpdateChatNameParams struct {
	Name           pgtype.Text `db:"name"`
	ChatID         string      `db:"chat_id"`
	UserID         string      `db:"user_id"`
	OrganisationID string      `db:"organisation_id"`
}

func (q *Queries) UpdateChatName(ctx context.Context, arg UpdateChatNameParams) (Chat, error) {
	row := q.db.QueryRow(ctx, updateChatName,
		arg.Name,
		arg.ChatID,
		arg.UserID,
		arg.OrganisationID,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const userCountByChatId = `-- name: UserCountByChatId :one
SELECT COUNT(*)
FROM chat_users
WHERE chat_id = $1
  AND organisation_id = $2
`

type UserCountByChatIdParams struct {
	ChatID         string `db:"chat_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) UserCountByChatId(ctx context.Context, arg UserCountByChatIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, userCountByChatId, arg.ChatID, arg.OrganisationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const userListByChatId = `-- name: UserListByChatId :many
SELECT users.id, users.role, users.organisation_id, users.first_name, users.last_name, users.email, users.password, users.recovery_token, users.recovery_sent_at, users.avatar_file_id, users.created_at, users.deleted_at, users.language, users.sex
FROM users
         INNER JOIN chat_users cu ON users.id = cu.user_id
WHERE cu.chat_id = $1
  AND users.organisation_id = $2
`

type UserListByChatIdParams struct {
	ChatID         string `db:"chat_id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) UserListByChatId(ctx context.Context, arg UserListByChatIdParams) ([]User, error) {
	rows, err := q.db.Query(ctx, userListByChatId, arg.ChatID, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.OrganisationID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Password,
			&i.RecoveryToken,
			&i.RecoverySentAt,
			&i.AvatarFileID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Language,
			&i.Sex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const usersInChat = `-- name: UsersInChat :many
SELECT users.id, users.role, users.organisation_id, users.first_name, users.last_name, users.email, users.password, users.recovery_token, users.recovery_sent_at, users.avatar_file_id, users.created_at, users.deleted_at, users.language, users.sex
FROM users
         INNER JOIN public.chat_users cu ON users.id = cu.user_id
WHERE cu.chat_id = $1
`

func (q *Queries) UsersInChat(ctx context.Context, chatID string) ([]User, error) {
	rows, err := q.db.Query(ctx, usersInChat, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.OrganisationID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Password,
			&i.RecoveryToken,
			&i.RecoverySentAt,
			&i.AvatarFileID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Language,
			&i.Sex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
