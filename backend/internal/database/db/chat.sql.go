// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: chat.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const botUserByChatId = `-- name: BotUserByChatId :one
SELECT users.id, role, users.organisation_id, first_name, last_name, email, password, recovery_token, recovery_sent_at, avatar_file_id, created_at, deleted_at, language, sex, cu.id, chat_id, user_id, cu.organisation_id
FROM users
         INNER JOIN public.chat_users cu ON users.id = cu.user_id
WHERE cu.id = $1
  AND users.role = 'bot'::user_role
  AND users.organisation_id = $2
LIMIT 1
`

type BotUserByChatIdParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

type BotUserByChatIdRow struct {
	ID               string             `db:"id"`
	Role             UserRole           `db:"role"`
	OrganisationID   string             `db:"organisation_id"`
	FirstName        string             `db:"first_name"`
	LastName         string             `db:"last_name"`
	Email            pgtype.Text        `db:"email"`
	Password         pgtype.Text        `db:"password"`
	RecoveryToken    pgtype.Text        `db:"recovery_token"`
	RecoverySentAt   pgtype.Timestamptz `db:"recovery_sent_at"`
	AvatarFileID     pgtype.Text        `db:"avatar_file_id"`
	CreatedAt        time.Time          `db:"created_at"`
	DeletedAt        pgtype.Timestamptz `db:"deleted_at"`
	Language         NullUserLang       `db:"language"`
	Sex              pgtype.Text        `db:"sex"`
	ID_2             string             `db:"id_2"`
	ChatID           string             `db:"chat_id"`
	UserID           string             `db:"user_id"`
	OrganisationID_2 string             `db:"organisation_id_2"`
}

func (q *Queries) BotUserByChatId(ctx context.Context, arg BotUserByChatIdParams) (BotUserByChatIdRow, error) {
	row := q.db.QueryRow(ctx, botUserByChatId, arg.ID, arg.OrganisationID)
	var i BotUserByChatIdRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.OrganisationID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.RecoveryToken,
		&i.RecoverySentAt,
		&i.AvatarFileID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Language,
		&i.Sex,
		&i.ID_2,
		&i.ChatID,
		&i.UserID,
		&i.OrganisationID_2,
	)
	return i, err
}

const chatById = `-- name: ChatById :one
SELECT id, name, organisation_id, updated_at, created_at, deleted_at, type
FROM chats
WHERE id = $1
LIMIT 1
`

func (q *Queries) ChatById(ctx context.Context, id string) (Chat, error) {
	row := q.db.QueryRow(ctx, chatById, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const chatMessageById = `-- name: ChatMessageById :one
SELECT id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
FROM chat_messages
WHERE id = $1
LIMIT 1
`

func (q *Queries) ChatMessageById(ctx context.Context, id string) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, chatMessageById, id)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const chatMessagesByChatIdWithoutOrg = `-- name: ChatMessagesByChatIdWithoutOrg :many
SELECT id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
FROM chat_messages
WHERE chat_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ChatMessagesByChatIdWithoutOrg(ctx context.Context, chatID string) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, chatMessagesByChatIdWithoutOrg, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.UserID,
			&i.Message,
			&i.OrganisationID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const chatUserByChatId = `-- name: ChatUserByChatId :many
SELECT id, chat_id, user_id, organisation_id
FROM chat_users
WHERE chat_id = $1
`

func (q *Queries) ChatUserByChatId(ctx context.Context, chatID string) ([]ChatUser, error) {
	rows, err := q.db.Query(ctx, chatUserByChatId, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatUser
	for rows.Next() {
		var i ChatUser
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.UserID,
			&i.OrganisationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (chat_id, user_id, message, organisation_id)
VALUES ($1, $2, $3, $4)
RETURNING id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
`

type CreateChatMessageParams struct {
	ChatID         string `db:"chat_id"`
	UserID         string `db:"user_id"`
	Message        string `db:"message"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.UserID,
		arg.Message,
		arg.OrganisationID,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateChatMessageMessageWithoutOrg = `-- name: UpdateChatMessageMessageWithoutOrg :one
UPDATE chat_messages
SET message = $2
WHERE id = $1
RETURNING id, chat_id, user_id, message, organisation_id, updated_at, created_at, deleted_at
`

type UpdateChatMessageMessageWithoutOrgParams struct {
	ID      string `db:"id"`
	Message string `db:"message"`
}

func (q *Queries) UpdateChatMessageMessageWithoutOrg(ctx context.Context, arg UpdateChatMessageMessageWithoutOrgParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessageMessageWithoutOrg, arg.ID, arg.Message)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.Message,
		&i.OrganisationID,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const usersInChat = `-- name: UsersInChat :many
SELECT users.id, users.role, users.organisation_id, users.first_name, users.last_name, users.email, users.password, users.recovery_token, users.recovery_sent_at, users.avatar_file_id, users.created_at, users.deleted_at, users.language, users.sex
FROM users
INNER JOIN public.chat_users cu ON users.id = cu.user_id
WHERE cu.chat_id = $1
`

func (q *Queries) UsersInChat(ctx context.Context, chatID string) ([]User, error) {
	rows, err := q.db.Query(ctx, usersInChat, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.OrganisationID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Password,
			&i.RecoveryToken,
			&i.RecoverySentAt,
			&i.AvatarFileID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Language,
			&i.Sex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
