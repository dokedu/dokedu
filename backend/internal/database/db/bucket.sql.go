// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: bucket.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bucketById = `-- name: BucketById :one
SELECT id, name, shared, organisation_id, created_at, deleted_at, user_id
FROM buckets
WHERE id = $1 AND organisation_id = $2 AND deleted_at IS NULL
LIMIT 1
`

type BucketByIdParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) BucketById(ctx context.Context, arg BucketByIdParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, bucketById, arg.ID, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const bucketByUserID = `-- name: BucketByUserID :one
SELECT id, name, shared, organisation_id, created_at, deleted_at, user_id
FROM buckets
WHERE user_id = $1 AND organisation_id = $2 AND deleted_at IS NULL AND shared = false  AND deleted_at IS NULL
LIMIT 1
`

type BucketByUserIDParams struct {
	UserID         pgtype.Text `db:"user_id"`
	OrganisationID string      `db:"organisation_id"`
}

func (q *Queries) BucketByUserID(ctx context.Context, arg BucketByUserIDParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, bucketByUserID, arg.UserID, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const createBucket = `-- name: CreateBucket :one
INSERT INTO buckets (name, shared, organisation_id, user_id)
VALUES ($1, $2, $3, $4)
RETURNING id, name, shared, organisation_id, created_at, deleted_at, user_id
`

type CreateBucketParams struct {
	Name           string      `db:"name"`
	Shared         bool        `db:"shared"`
	OrganisationID string      `db:"organisation_id"`
	UserID         pgtype.Text `db:"user_id"`
}

func (q *Queries) CreateBucket(ctx context.Context, arg CreateBucketParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, createBucket,
		arg.Name,
		arg.Shared,
		arg.OrganisationID,
		arg.UserID,
	)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const createBucketWithoutUser = `-- name: CreateBucketWithoutUser :one
INSERT INTO buckets (name, shared, organisation_id)
VALUES ($1, $2, $3)
RETURNING id, name, shared, organisation_id, created_at, deleted_at, user_id
`

type CreateBucketWithoutUserParams struct {
	Name           string `db:"name"`
	Shared         bool   `db:"shared"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) CreateBucketWithoutUser(ctx context.Context, arg CreateBucketWithoutUserParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, createBucketWithoutUser, arg.Name, arg.Shared, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const createInternalBucket = `-- name: CreateInternalBucket :one
INSERT INTO buckets (name, shared, organisation_id)
VALUES ($1, $2, $3)
RETURNING id, name, shared, organisation_id, created_at, deleted_at, user_id
`

type CreateInternalBucketParams struct {
	Name           string `db:"name"`
	Shared         bool   `db:"shared"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) CreateInternalBucket(ctx context.Context, arg CreateInternalBucketParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, createInternalBucket, arg.Name, arg.Shared, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const deleteBucket = `-- name: DeleteBucket :one
UPDATE buckets
SET deleted_at = now()
WHERE id = $1 AND organisation_id = $2
RETURNING id, name, shared, organisation_id, created_at, deleted_at, user_id
`

type DeleteBucketParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) DeleteBucket(ctx context.Context, arg DeleteBucketParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, deleteBucket, arg.ID, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const internalBucketByName = `-- name: InternalBucketByName :one
SELECT id, name, shared, organisation_id, created_at, deleted_at, user_id
FROM buckets
WHERE name = $1 AND organisation_id = $2 AND user_id IS NULL AND deleted_at IS NULL
LIMIT 1
`

type InternalBucketByNameParams struct {
	Name           string `db:"name"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) InternalBucketByName(ctx context.Context, arg InternalBucketByNameParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, internalBucketByName, arg.Name, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const updateBucketName = `-- name: UpdateBucketName :one
UPDATE buckets
SET name = $1
WHERE id = $2 AND organisation_id = $3
RETURNING id, name, shared, organisation_id, created_at, deleted_at, user_id
`

type UpdateBucketNameParams struct {
	Name           string `db:"name"`
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) UpdateBucketName(ctx context.Context, arg UpdateBucketNameParams) (Bucket, error) {
	row := q.db.QueryRow(ctx, updateBucketName, arg.Name, arg.ID, arg.OrganisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}
