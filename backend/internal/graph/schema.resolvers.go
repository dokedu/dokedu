package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/dataloaders"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	meili "github.com/dokedu/dokedu/backend/internal/modules/meilisearch"
	"github.com/jackc/pgx/v5/pgtype"
	meilisearch "github.com/meilisearch/meilisearch-go"
	"github.com/samber/lo"
	"github.com/uptrace/bun"
)

// Type is the resolver for the type field.
func (r *competenceResolver) Type(ctx context.Context, obj *db.Competence) (db.CompetenceType, error) {
	return obj.CompetenceType, nil
}

// Color is the resolver for the color field.
func (r *competenceResolver) Color(ctx context.Context, obj *db.Competence) (string, error) {
	if obj.Color.Valid {
		return obj.Color.String, nil
	}

	return "", nil
}

// Parents is the resolver for the parents field.
func (r *competenceResolver) Parents(ctx context.Context, obj *db.Competence) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetCompetenceParents(ctx, obj.ID, currentUser)
}

// SortOrder is the resolver for the sortOrder field.
func (r *competenceResolver) SortOrder(ctx context.Context, obj *db.Competence) (int, error) {
	panic(fmt.Errorf("not implemented: SortOrder - sortOrder"))
}

// Competences is the resolver for the competences field.
func (r *competenceResolver) Competences(ctx context.Context, obj *db.Competence, search *string, sort *model.CompetenceSort) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var competences []*db.Competence
	query := r.DB.
		NewQueryBuilder().
		Select("*").
		From("competences").
		Where("competence_id = ?", obj.ID).
		Where("organisation_id = ?", currentUser.OrganisationID)

	if sort != nil {
		switch sort.Field {
		case model.CompetenceSortFieldSortOrder:
			query.OrderBy("sort_order ASC")
			query.OrderBy("name ASC")
		case model.CompetenceSortFieldName:
			query.OrderBy("name ASC")
		case model.CompetenceSortFieldCreatedAt:
			query.OrderBy("created_at ASC")
		}
	} else {
		//query.Order("name ASC")
	}

	if search != nil && *search != "" {
		query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", *search))
	}

	err = query.Scan(ctx)
	if err != nil {
		return nil, err
	}

	return competences, nil
}

// UserCompetences is the resolver for the userCompetences field.
func (r *competenceResolver) UserCompetences(ctx context.Context, obj *db.Competence, userID *string) ([]*db.UserCompetence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if userID == nil {
		return []*db.UserCompetence{}, nil
	}

	userCompetences, err := r.DB.UserCompetenceListByUserIdAndCompetenceId(ctx, db.UserCompetenceListByUserIdAndCompetenceIdParams{
		UserID:         *userID,
		CompetenceID:   obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	return lo.ToSlicePtr(userCompetences), nil
}

// Tendency is the resolver for the tendency field.
func (r *competenceResolver) Tendency(ctx context.Context, obj *db.Competence, userID string) (*model.CompetenceTendency, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if obj.CompetenceType == db.CompetenceTypeCompetence {
		return nil, nil
	}

	user, err := r.DB.UserById(ctx, db.UserByIdParams{
		ID:             userID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// TODO: how is that even possible?
	if currentUser.OrganisationID != user.OrganisationID {
		return nil, errors.New("user does not belong to the same organisation")
	}

	childrenCount, err := r.DB.CompetenceChildrenCount(ctx, db.CompetenceChildrenCountParams{
		CompetenceID:   pgtype.Text{String: obj.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	userCompetenceCount, err := r.DB.UserCompetenceCount(ctx, db.UserCompetenceCountParams{
		OrganisationID: currentUser.OrganisationID,
		UserID:         user.ID,
		CompetenceID:   obj.ID,
	})
	if err != nil {
		return nil, err
	}

	var tendency model.CompetenceTendency
	tendency.CountLearnedCompetences = int(userCompetenceCount)
	tendency.CountChildCompetences = int(childrenCount)

	tendency.Tendency = float64(tendency.CountLearnedCompetences) / float64(tendency.CountChildCompetences)

	return &tendency, nil
}

// CreateStudent is the resolver for the createStudent field.
func (r *mutationResolver) CreateStudent(ctx context.Context, input model.CreateStudentInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	user, err := r.DB.CreateUser(ctx, db.CreateUserParams{
		Role:           db.UserRoleStudent,
		OrganisationID: currentUser.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		Email:          pgtype.Text{},
		Password:       pgtype.Text{},
		Language:       db.NullUserLang{},
		Sex:            pgtype.Text{},
	})
	if err != nil {
		return nil, nil
	}

	// Create user_student struct
	student := db.CreateUserStudentParams{
		UserID:         user.ID,
		OrganisationID: currentUser.OrganisationID,
		Grade:          int32(input.Grade),
	}

	if input.Birthday != nil {
		student.Birthday = pgtype.Date{Time: *input.Birthday, Valid: true}
	}
	if input.JoinedAt != nil {
		student.JoinedAt = pgtype.Timestamptz{Time: *input.JoinedAt, Valid: true}
	}
	if input.LeftAt != nil {
		student.LeftAt = pgtype.Timestamptz{Time: *input.LeftAt, Valid: true}
	}
	if input.Emoji != nil {
		student.Emoji = pgtype.Text{String: *input.Emoji, Valid: true}
	}

	_, err = r.DB.CreateUserStudent(ctx, student)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// CreateUserCompetence is the resolver for the createUserCompetence field.
func (r *mutationResolver) CreateUserCompetence(ctx context.Context, input model.CreateUserCompetenceInput) (*db.UserCompetence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if input.UserID == "" {
		return nil, errors.New("user id is required")
	}
	if input.CompetenceID == "" {
		return nil, errors.New("competence id is required")
	}

	userCompetenceParams := db.CreateUserCompetenceWithoutEntryParams{
		UserID:         input.UserID,
		Level:          int32(input.Level),
		CreatedBy:      pgtype.Text{String: currentUser.ID, Valid: true},
		CompetenceID:   input.CompetenceID,
		OrganisationID: currentUser.OrganisationID,
	}

	userCompetence, err := r.DB.CreateUserCompetenceWithoutEntry(ctx, userCompetenceParams)
	return &userCompetence, err
}

// ArchiveUserCompetence is the resolver for the archiveUserCompetence field.
func (r *mutationResolver) ArchiveUserCompetence(ctx context.Context, id string) (*db.UserCompetence, error) {
	panic(fmt.Errorf("not implemented: ArchiveUserCompetence - archiveUserCompetence"))
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check if color is set
	color := input.Color
	if color == "" {
		color = "blue"
	}

	tagParams := db.CreateTagParams{
		OrganisationID: currentUser.OrganisationID,
		Name:           input.Name,
		Color:          pgtype.Text{String: color, Valid: true},
	}

	tag, err := r.DB.CreateTag(ctx, tagParams)
	// TODO: check if returns error because tag already exists with the same name
	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// ArchiveTag is the resolver for the archiveTag field.
func (r *mutationResolver) ArchiveTag(ctx context.Context, id string) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	tag, err := r.DB.DeleteTag(ctx, db.DeleteTagParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id string, input model.CreateTagInput) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	tag, err := r.DB.UpsertTag(ctx, db.UpsertTagParams{
		Name:           input.Name,
		Color:          pgtype.Text{String: input.Color, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	return &tag, err
}

// UpdateCompetence is the resolver for the updateCompetence field.
func (r *mutationResolver) UpdateCompetence(ctx context.Context, input model.UpdateCompetenceInput) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var color pgtype.Text
	if input.Color != nil {
		color.String = *input.Color
	} else {
		color.String = "blue"
	}

	competence, err := r.DB.UpdateCompetenceColor(ctx, db.UpdateCompetenceColorParams{
		Color:          color,
		CompetenceID:   input.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// UpdateCompetenceSorting is the resolver for the updateCompetenceSorting field.
func (r *mutationResolver) UpdateCompetenceSorting(ctx context.Context, input model.UpdateCompetenceSortingInput) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	ids := make([]string, len(input.Competences))
	for i, id := range input.Competences {
		ids[i] = id.ID
	}

	competences, err := r.DB.CompetenceListByIds(ctx, db.CompetenceListByIdsParams{
		Ids:            ids,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// if length of competences is not equal to length of input, then some competences were not found
	if len(competences) != len(input.Competences) {
		return nil, fmt.Errorf("some competences were not found %v, %v", len(competences), len(input.Competences))
	}

	// create a map of competences for easy lookup
	competenceMap := make(map[string]*db.Competence)
	for _, competence := range competences {
		competenceMap[competence.ID] = &competence
	}

	// update the sorting
	for i, id := range ids {
		competenceMap[id].SortOrder = pgtype.Int4{Int32: int32(i), Valid: true}
	}

	for _, competence := range competences {
		sortOrder := competenceMap[competence.ID].SortOrder
		_, err = r.DB.UpdateCompetenceSortOrder(ctx, db.UpdateCompetenceSortOrderParams{
			SortOrder:      sortOrder,
			CompetenceID:   competence.ID,
			OrganisationID: currentUser.OrganisationID,
		})
		if err != nil {
			return nil, err
		}
	}

	return lo.ToSlicePtr(competences), nil
}

// CreateCompetence is the resolver for the createCompetence field.
func (r *mutationResolver) CreateCompetence(ctx context.Context, input model.CreateCompetenceInput) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	subject, err := r.DB.CompetenceById(ctx, db.CompetenceByIdParams{
		ID:             input.ParentID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("subject not found")
	}

	// grades with default array from 1-10
	defaultGrades := make([]int32, 10)
	for i := 0; i < 10; i++ {
		defaultGrades[i] = int32(i + 1)
	}

	competenceParams := db.CreateCompetenceParams{
		CompetenceType: db.CompetenceTypeCompetence,
		CompetenceID:   pgtype.Text{String: subject.ID, Valid: true},
		Name:           input.Name,
		Grades:         defaultGrades,
		OrganisationID: currentUser.OrganisationID,
		CreatedBy:      pgtype.Text{String: currentUser.ID, Valid: true},
	}

	competence, err := r.DB.CreateCompetence(ctx, competenceParams)
	if err != nil {
		return nil, errors.New("creating competence failed")
	}

	return &competence, nil
}

// Competence is the resolver for the competence field.
func (r *queryResolver) Competence(ctx context.Context, id string) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	competence, err := r.DB.CompetenceById(ctx, db.CompetenceByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	return &competence, err
}

// Competences is the resolver for the competences field.
func (r *queryResolver) Competences(ctx context.Context, limit *int, offset *int, filter *model.CompetenceFilterInput, search *string, sort *model.CompetenceSort) (*model.CompetenceConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var ids []string

	if search != nil && len(*search) > 0 {
		indexName := r.Meili.GetCompetenceIndex(currentUser.OrganisationID)
		filterStr := ""

		if filter != nil {
			if filter.Parents != nil && len(filter.Parents) > 0 {
				var parents []string
				for _, parent := range filter.Parents {
					parents = append(parents, *parent)

				}
				filterStr += "parents IN [" + strings.Join(parents, ", ") + "]"
			}

			// TODO: code repeats, find more elegant solution
			if filter.Type != nil && len(filter.Type) > 0 {
				var types []string
				for _, _type := range filter.Type {
					types = append(types, string(*_type))

				}
				filterStr += "competence_type IN [" + strings.Join(types, ", ") + "]"
			}
		}

		searchRequest := meilisearch.SearchRequest{
			Limit: int64(pageLimit),
		}

		if filterStr != "" {
			searchRequest.Filter = filterStr
		}

		term := *search

		response, err := r.Meili.Client.Index(indexName).SearchRaw(term, &searchRequest)
		if err != nil {
			return nil, err
		}

		var results meili.SearchResponseCompetence
		err = json.Unmarshal(*response, &results)
		if err != nil {
			return nil, err
		}

		for _, hit := range results.Hits {
			ids = append(ids, hit.ID)
		}

		fmt.Println(ids)
	}

	competences, err := r.DB.CompetenceList(ctx, currentUser.OrganisationID)
	query := r.DB.NewQueryBuilder().
		Select("*").
		From("competences").
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(uint64(pageLimit)).
		Offset(uint64(pageOffset))

	if len(ids) > 0 {
		query.Where("id IN (?)", bun.In(ids))
	} else {
		if sort != nil {
			query.OrderBy("competence_type")
			switch sort.Field {
			case model.CompetenceSortFieldSortOrder:
				query.OrderBy("sort_order ASC")
			case model.CompetenceSortFieldName:
				query.OrderBy("name ASC")
			case model.CompetenceSortFieldCreatedAt:
				query.OrderBy("created_at ASC")
			}
		} else {
			query.OrderBy("competence_type")
			query.OrderBy("name ASC")
		}

		if filter != nil {
			if filter.Type != nil {
				if len(filter.Type) == 1 {
					query.Where("competence_type = ?", filter.Type[0])
				} else {
					query.Where("competence_type IN (?)", bun.In(filter.Type))
				}
			}

			if filter.Parents != nil {
				if len(filter.Parents) == 1 {
					query.Where("competence_id = ?", filter.Parents[0])
				} else {
					query.Where("competence_id IN (?)", bun.In(filter.Parents))
				}
			}
		}
	}

	err = query.Scan(competences)
	if err != nil {
		return nil, err
	}

	count := 10_000

	page, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	page.CurrentPage = pageOffset / pageLimit
	return &model.CompetenceConnection{
		Edges:      lo.ToSlicePtr(competences),
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	tag, err := r.DB.TagById(ctx, db.TagByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	return &tag, err
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, limit *int, offset *int, search *string) (*model.TagConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	tags, err := r.DB.TagList(ctx, db.TagListParams{
		OrganisationID: currentUser.OrganisationID,
		Offset:         int32(pageOffset),
		Limit:          int32(pageLimit),
		Search:         "%" + *search + "%",
	})
	if err != nil {
		return nil, err
	}

	// TODO: get the count from the database
	count := 10_000

	// Get the pageInfo
	page, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	return &model.TagConnection{
		Edges:      lo.ToSlicePtr(tags),
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// UserStudents is the resolver for the userStudents field.
func (r *queryResolver) UserStudents(ctx context.Context, limit *int, offset *int) (*model.UserStudentConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	userStudents, err := r.DB.UserStudentList(ctx, db.UserStudentListParams{
		OrganisationID: currentUser.OrganisationID,
		Offset:         int32(pageOffset),
		Limit:          int32(pageLimit),
	})
	if err != nil {
		return nil, err
	}

	count, err := r.DB.UserStudentCount(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	page, err := helper.CreatePageInfo(pageOffset, pageLimit, int(count))
	if err != nil {
		return nil, err
	}

	return &model.UserStudentConnection{
		Edges:      lo.ToSlicePtr(userStudents),
		PageInfo:   page,
		TotalCount: int(count),
	}, nil
}

// UserStudent is the resolver for the userStudent field.
func (r *queryResolver) UserStudent(ctx context.Context, id string) (*db.UserStudent, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	userStudent, err := r.DB.UserStudentByUserId(ctx, db.UserStudentByUserIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// Color is the resolver for the color field.
func (r *tagResolver) Color(ctx context.Context, obj *db.Tag) (string, error) {
	if obj.Color.Valid {
		return obj.Color.String, nil
	}

	return "", nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *tagResolver) DeletedAt(ctx context.Context, obj *db.Tag) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// Competence is the resolver for the competence field.
func (r *userCompetenceResolver) Competence(ctx context.Context, obj *db.UserCompetence) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	competence, err := r.DB.CompetenceByIdWithDeleted(ctx, db.CompetenceByIdWithDeletedParams{
		ID:             obj.CompetenceID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// Entry is the resolver for the entry field.
func (r *userCompetenceResolver) Entry(ctx context.Context, obj *db.UserCompetence) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if sql.NullString(obj.EntryID).String == "" {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             obj.EntryID.String,
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// User is the resolver for the user field.
func (r *userCompetenceResolver) User(ctx context.Context, obj *db.UserCompetence) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// CreatedBy is the resolver for the createdBy field.
func (r *userCompetenceResolver) CreatedBy(ctx context.Context, obj *db.UserCompetence) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	user, err := r.DB.UserById(ctx, db.UserByIdParams{
		ID:             obj.CreatedBy.String,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// LeftAt is the resolver for the leftAt field.
func (r *userStudentResolver) LeftAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.LeftAt.Valid {
		return &obj.LeftAt.Time, nil
	}

	return nil, nil
}

// Birthday is the resolver for the birthday field.
func (r *userStudentResolver) Birthday(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.Birthday.Valid {
		return &obj.Birthday.Time, nil
	}
	return nil, nil
}

// Nationality is the resolver for the nationality field.
func (r *userStudentResolver) Nationality(ctx context.Context, obj *db.UserStudent) (*string, error) {
	if obj.Nationality.Valid {
		return &obj.Nationality.String, nil
	}
	return nil, nil
}

// Comments is the resolver for the comments field.
func (r *userStudentResolver) Comments(ctx context.Context, obj *db.UserStudent) (*string, error) {
	if obj.Comments.Valid {
		return &obj.Comments.String, nil
	}
	return nil, nil
}

// JoinedAt is the resolver for the joinedAt field.
func (r *userStudentResolver) JoinedAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.JoinedAt.Valid {
		return &obj.JoinedAt.Time, nil
	}

	return nil, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userStudentResolver) DeletedAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}
	return nil, nil
}

// EntriesCount is the resolver for the entriesCount field.
func (r *userStudentResolver) EntriesCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.EntryCountByUserId(ctx, db.EntryCountByUserIdParams{
		UserID:         obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// CompetencesCount is the resolver for the competencesCount field.
func (r *userStudentResolver) CompetencesCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.UserCompetenceCountByUserId(ctx, db.UserCompetenceCountByUserIdParams{
		UserID:         obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// EventsCount is the resolver for the eventsCount field.
func (r *userStudentResolver) EventsCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.EntryEventCountByUserId(ctx, db.EntryEventCountByUserIdParams{
		UserID:         obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// Emoji is the resolver for the emoji field.
func (r *userStudentResolver) Emoji(ctx context.Context, obj *db.UserStudent) (*string, error) {
	if obj.Emoji.Valid {
		return &obj.Emoji.String, nil
	}
	return nil, nil
}

// User is the resolver for the user field.
func (r *userStudentResolver) User(ctx context.Context, obj *db.UserStudent) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// MissedHours is the resolver for the missedHours field.
func (r *userStudentResolver) MissedHours(ctx context.Context, obj *db.UserStudent) (int, error) {
	if obj.MissedHours.Valid {
		return int(obj.MissedHours.Int32), nil
	}
	return 0, nil
}

// MissedHoursExcused is the resolver for the missedHoursExcused field.
func (r *userStudentResolver) MissedHoursExcused(ctx context.Context, obj *db.UserStudent) (int, error) {
	if obj.MissedHoursExcused.Valid {
		return int(obj.MissedHoursExcused.Int32), nil
	}
	return 0, nil
}

// Competence returns CompetenceResolver implementation.
func (r *Resolver) Competence() CompetenceResolver { return &competenceResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Tag returns TagResolver implementation.
func (r *Resolver) Tag() TagResolver { return &tagResolver{r} }

// UserCompetence returns UserCompetenceResolver implementation.
func (r *Resolver) UserCompetence() UserCompetenceResolver { return &userCompetenceResolver{r} }

// UserStudent returns UserStudentResolver implementation.
func (r *Resolver) UserStudent() UserStudentResolver { return &userStudentResolver{r} }

type competenceResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type userCompetenceResolver struct{ *Resolver }
type userStudentResolver struct{ *Resolver }
