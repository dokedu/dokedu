package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"math/rand"
	"strings"
	"time"

	"github.com/dokedu/dokedu/backend/internal/dataloaders"
	"github.com/dokedu/dokedu/backend/internal/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	meili "github.com/dokedu/dokedu/backend/internal/modules/meilisearch"
	"github.com/dokedu/dokedu/backend/internal/msg"
	nanoid "github.com/matoous/go-nanoid/v2"
	meilisearch "github.com/meilisearch/meilisearch-go"
	"github.com/uptrace/bun"
	"golang.org/x/crypto/bcrypt"
)

// Type is the resolver for the type field.
func (r *competenceResolver) Type(ctx context.Context, obj *db.Competence) (db.CompetenceType, error) {
	return obj.CompetenceType, nil
}

// Color is the resolver for the color field.
func (r *competenceResolver) Color(ctx context.Context, obj *db.Competence) (string, error) {
	if obj.Color.Valid {
		return obj.Color.String, nil
	}

	return "", nil
}

// Parents is the resolver for the parents field.
func (r *competenceResolver) Parents(ctx context.Context, obj *db.Competence) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetCompetenceParents(ctx, obj.ID, currentUser)
}

// Competences is the resolver for the competences field.
func (r *competenceResolver) Competences(ctx context.Context, obj *db.Competence, search *string, sort *model.CompetenceSort) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var competences []*db.Competence
	query := r.DB.
		NewSelect().
		Model(&competences).
		Where("competence_id = ?", obj.ID).
		Where("organisation_id = ?", currentUser.OrganisationID)

	if sort != nil {
		switch sort.Field {
		case model.CompetenceSortFieldSortOrder:
			query.Order("sort_order ASC")
			query.Order("name ASC")
		case model.CompetenceSortFieldName:
			query.Order("name ASC")
		case model.CompetenceSortFieldCreatedAt:
			query.Order("created_at ASC")
		}
	} else {
		//query.Order("name ASC")
	}

	if search != nil && *search != "" {
		query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", *search))
	}

	err = query.Scan(ctx)
	if err != nil {
		return nil, err
	}

	return competences, nil
}

// UserCompetences is the resolver for the userCompetences field.
func (r *competenceResolver) UserCompetences(ctx context.Context, obj *db.Competence, userID *string) ([]*db.UserCompetence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if userID == nil {
		return []*db.UserCompetence{}, nil
	}

	var userCompetences []*db.UserCompetence
	err = r.DB.NewSelect().
		Model(&userCompetences).
		Where("competence_id = ?", obj.ID).
		Where("user_id = ?", *userID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Order("created_at DESC").
		Scan(ctx)

	if err != nil {
		return nil, err
	}

	return userCompetences, nil
}

// Tendency is the resolver for the tendency field.
func (r *competenceResolver) Tendency(ctx context.Context, obj *db.Competence, userID string) (*model.CompetenceTendency, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if obj.CompetenceType == db.CompetenceTypeCompetence {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", userID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	if currentUser.OrganisationID != user.OrganisationID {
		return nil, errors.New("user does not belong to the same organisation")
	}

	var tendency model.CompetenceTendency

	childCountQuery := `WITH RECURSIVE child_competences AS ( SELECT id, competence_type FROM competences WHERE competence_id = ? UNION ALL SELECT c.id, c.competence_type FROM competences c INNER JOIN child_competences cc ON c.competence_id = cc.id ) SELECT COUNT(id) FROM child_competences WHERE competence_type = 'competence'`
	err = r.DB.NewRaw(childCountQuery, obj.ID).Scan(ctx, &tendency.CountChildCompetences)

	learnedCountQuery := `SELECT COUNT(DISTINCT user_competences.competence_id) FROM user_competences WHERE organisation_id = ? AND user_id = ? AND competence_id IN ( WITH RECURSIVE child_competences AS ( SELECT id, competence_type FROM competences WHERE competence_id = ? UNION ALL SELECT c.id, c.competence_type FROM competences c INNER JOIN child_competences cc ON c.competence_id = cc.id ) SELECT id FROM child_competences WHERE competence_type = 'competence' )`
	err = r.DB.NewRaw(learnedCountQuery, currentUser.OrganisationID, userID, obj.ID).Scan(ctx, &tendency.CountLearnedCompetences)

	tendency.Tendency = float64(tendency.CountLearnedCompetences) / float64(tendency.CountChildCompetences)

	return &tendency, nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInPayload, error) {
	var user db.User
	err := r.DB.NewSelect().Model(&user).Where("email = ?", strings.ToLower(input.Email)).Scan(ctx)
	if err != nil {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	var organisation db.Organisation
	err = r.DB.NewSelect().Model(&organisation).Where("id = ?", user.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	// user.Password is a sql.NullString, so we need to check if it is valid
	if !user.Password.Valid {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password.String), []byte(input.Password)); err != nil {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	// Generate a new token
	token, err := nanoid.New(32)
	if err != nil {
		return nil, errors.New("unable to generate a token")
	}

	// Save the token in the database
	session := db.Session{
		UserID: user.ID,
		Token:  token,
	}

	_, err = r.DB.NewInsert().Model(&session).Exec(ctx)
	if err != nil {
		return nil, errors.New("unable to generate a token")
	}

	return &model.SignInPayload{
		Token:         token,
		EnabledApps:   organisation.EnabledApps,
		Language:      string(user.Language),
		SetupComplete: organisation.SetupComplete,
		User:          &user,
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordPayload, error) {
	var user db.User

	if input.Token == nil {
		currentUser := middleware.ForContext(ctx)
		if currentUser == nil {
			return nil, errors.New("no user found in the context")
		}

		err := r.DB.NewSelect().Model(&user).Where("id = ?", currentUser.ID).Scan(ctx)
		if err != nil {
			return &model.ResetPasswordPayload{
				Success:      false,
				Unauthorized: true,
			}, nil
		}

	} else {
		err := r.DB.NewSelect().Model(&user).Where("recovery_token = ?", input.Token).Scan(ctx)
		if err != nil {
			return &model.ResetPasswordPayload{
				Success:      false,
				InvalidToken: true,
			}, nil
		}

		if time.Now().After(user.RecoverySentAt.Add(24 * time.Hour)) {
			return &model.ResetPasswordPayload{
				Success:      false,
				TokenExpired: true,
			}, nil
		}

	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return &model.ResetPasswordPayload{
			Success:       false,
			UnableToReset: true,
		}, nil
	}

	_, err = r.DB.NewUpdate().Model(&user).Set("password = ?", string(hashedPassword)).Set("recovery_token = NULL").Set("recovery_sent_at = NULL").WherePK().Exec(ctx)
	if err != nil {
		return &model.ResetPasswordPayload{
			Success:       false,
			UnableToReset: true,
		}, nil
	}

	var emailAccount db.EmailAccount
	_ = r.DB.NewSelect().Model(&emailAccount).Where("user_id = ?", user.ID).Scan(ctx)
	if len(emailAccount.ID) > 1 {
		err = r.DB.NewUpdate().Model(&emailAccount).Set("secret = ?", string(hashedPassword)).WherePK().Where("organisation_id = ?", user.OrganisationID).Scan(ctx)
		if err != nil {
			return &model.ResetPasswordPayload{
				Success:       false,
				UnableToReset: true,
			}, nil
		}
	}

	return &model.ResetPasswordPayload{
		Success: true,
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (*model.ForgotPasswordPayload, error) {
	var user db.User
	err := r.DB.NewSelect().Model(&user).Where("email = ?", strings.ToLower(input.Email)).Scan(ctx)
	if err != nil {
		return &model.ForgotPasswordPayload{
			Success: false,
		}, nil
	}

	token := nanoid.Must(32)

	_, err = r.DB.NewUpdate().Model(&user).Set("recovery_token = ?", token).Set("recovery_sent_at = now()").Where("id = ?", user.ID).Exec(ctx)
	if err != nil {
		return &model.ForgotPasswordPayload{
			Success: false,
		}, nil
	}

	err = r.Mailer.SendPasswordReset(input.Email, user.FirstName, user.Language, token)
	if err != nil {
		return &model.ForgotPasswordPayload{
			Success: false,
		}, nil
	}

	return &model.ForgotPasswordPayload{
		Success: true,
	}, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (bool, error) {
	currentUser := middleware.ForContext(ctx)
	if currentUser == nil {
		return false, errors.New("no user found in the context")
	}

	// TODO: suggestion: use a hard delete instead of a soft delete
	// TODO: suggestion: perhaps delete all sessions for the user?
	var session db.Session
	_, err := r.DB.NewUpdate().
		Model(&session).
		Set("deleted_at = now()").
		Where("user_id = ?", currentUser.ID).
		Where("token = ?", currentUser.Token).
		Exec(ctx)

	if err != nil {
		return false, err
	}

	return true, nil
}

// AcceptInvite is the resolver for the acceptInvite field.
func (r *mutationResolver) AcceptInvite(ctx context.Context, token string, input model.SignUpInput) (*model.SignInPayload, error) {
	panic(fmt.Errorf("not implemented: AcceptInvite - acceptInvite"))
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var organisation db.Organisation
	err = r.DB.NewSelect().Model(&organisation).Where("id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	//// check if the email is in the allowed domains
	//if isStringInArray(input.Email, organisation.AllowedDomains) {
	//	return nil, errors.New("email is not in the allowed domains (allowed domains: " + strings.Join(organisation.AllowedDomains, ", ") + ")")
	//}

	var count int
	count, err = r.DB.NewSelect().Model(&db.User{}).Where("organisation_id = ?", currentUser.OrganisationID).Where("email = ?", input.Email).Count(ctx)
	if err != nil {
		return nil, err
	}
	if count > 0 {
		return nil, errors.New("email is already in the database")
	}

	// create a new user
	user := db.User{
		OrganisationID: currentUser.OrganisationID,
		Role:           input.Role,
		Email:          sql.NullString{String: input.Email, Valid: true},
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	}

	// insert the user into the database
	err = r.DB.NewInsert().Model(&user).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Email the user
	token := nanoid.Must(32)
	_, err = r.DB.NewUpdate().Model(&user).Set("recovery_token = ?", token).Set("recovery_sent_at = now()").Where("id = ?", user.ID).Exec(ctx)
	if err != nil {
		return nil, err
	}

	err = r.Mailer.SendInvite(input.Email, user.FirstName, organisation.Name, currentUser.Language, token)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// update the user
	user := db.User{
		ID:             input.ID,
		OrganisationID: currentUser.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	}

	_, err = r.DB.NewUpdate().
		Model(&user).
		OmitZero().
		WherePK().
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	// Update the user_student if the role is student
	if user.Role == "student" {
		student := db.UserStudent{
			UserID:         user.ID,
			OrganisationID: currentUser.OrganisationID,
		}

		// Check the optional fields
		if input.Grade != nil {
			student.Grade = int32(*input.Grade)
		}
		if input.Birthday != nil {
			student.Birthday = bun.NullTime{Time: *input.Birthday}
		}
		if input.JoinedAt != nil {
			student.JoinedAt = bun.NullTime{Time: *input.JoinedAt}
		}
		if input.LeftAt != nil {
			student.LeftAt = bun.NullTime{Time: *input.LeftAt}
		}
		if input.Emoji != nil {
			student.Emoji = sql.NullString{String: *input.Emoji, Valid: true}
		}
		if input.MissedHours != nil {
			student.MissedHours = int32(*input.MissedHours)
		}
		if input.MissedHoursExcused != nil {
			student.MissedHoursExcused = int32(*input.MissedHoursExcused)
		}

		_, err = r.DB.NewUpdate().
			Model(&student).
			OmitZero().
			Where("user_id = ?", user.ID).
			Where("organisation_id = ?", currentUser.OrganisationID).
			Returning("*").
			Exec(ctx)
		if err != nil {
			return nil, nil
		}
	}

	return &user, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check whether the user is already archived
	count, err := r.DB.NewSelect().Model(&db.User{}).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Where("deleted_at IS NOT NULL").Count(ctx)
	if err != nil {
		return nil, err
	}
	if count > 0 {
		return nil, errors.New("user is already archived")
	}

	user := &db.User{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
		DeletedAt: bun.NullTime{
			Time: time.Now(),
		},
	}

	// archive the user by setting the deleted_at field to the current time
	res, err := r.DB.NewUpdate().Model(user).Column("deleted_at").Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return nil, err
	}
	if affected == 0 {
		return nil, errors.New("user not found")
	}

	// If the user is a student, we also need to archive the user_student
	if user.Role == "student" {
		student := db.UserStudent{
			UserID:         user.ID,
			OrganisationID: currentUser.OrganisationID,
			DeletedAt: bun.NullTime{
				Time: time.Now(),
			},
		}

		_, err = r.DB.NewUpdate().Model(&student).Column("deleted_at").Where("user_id = ?", user.ID).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	// Remove the sessions for the user
	_, err = r.DB.NewDelete().Model(&db.Session{}).Where("user_id = ?", user.ID).Exec(ctx)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return nil, err
	}

	return user, nil
}

// UpdateUserLanguage is the resolver for the updateUserLanguage field.
func (r *mutationResolver) UpdateUserLanguage(ctx context.Context, language db.UserLanguage) (*db.User, error) {
	// We get the currentUser from context
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	updatedUser := db.User{
		ID:             currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
		Language:       language,
	}

	// update the user
	_, err = r.DB.NewUpdate().
		Model(&updatedUser).
		Column("language").
		Where("id = ?", currentUser.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &updatedUser, nil
}

// SendUserInvite is the resolver for the sendUserInvite field.
func (r *mutationResolver) SendUserInvite(ctx context.Context, id string) (bool, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	// Get the user
	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)

	// Get the organisation
	var organisation db.Organisation
	err = r.DB.NewSelect().Model(&organisation).Where("id = ?", currentUser.OrganisationID).Scan(ctx)

	// Email the user
	token := nanoid.Must(32)
	_, err = r.DB.NewUpdate().Model(&user).Set("recovery_token = ?", token).Set("recovery_sent_at = now()").Where("id = ?", user.ID).Exec(ctx)
	if err != nil {
		return false, err
	}

	err = r.Mailer.SendInvite(user.Email.String, user.FirstName, organisation.Name, currentUser.Language, token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateStudent is the resolver for the createStudent field.
func (r *mutationResolver) CreateStudent(ctx context.Context, input model.CreateStudentInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// Create user first
	user := db.User{
		OrganisationID: currentUser.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		Role:           "student",
		Email:          sql.NullString{},
	}

	// Insert and get the new id
	err = r.DB.NewInsert().Model(&user).Scan(ctx)
	if err != nil {
		return nil, nil
	}

	// Create user_student struct
	student := db.UserStudent{
		UserID:         user.ID,
		OrganisationID: currentUser.OrganisationID,
		Grade:          int32(input.Grade),
	}

	if input.Birthday != nil {
		student.Birthday = bun.NullTime{Time: *input.Birthday}
	}
	if input.JoinedAt != nil {
		student.JoinedAt = bun.NullTime{Time: *input.JoinedAt}
	}
	if input.LeftAt != nil {
		student.LeftAt = bun.NullTime{Time: *input.LeftAt}
	}
	if input.Emoji != nil {
		student.Emoji = sql.NullString{String: *input.Emoji, Valid: true}
	}

	// Insert the user_student
	err = r.DB.NewInsert().Model(&student).Scan(ctx)
	if err != nil {
		return nil, nil
	}

	return &user, nil
}

// CreateUserCompetence is the resolver for the createUserCompetence field.
func (r *mutationResolver) CreateUserCompetence(ctx context.Context, input model.CreateUserCompetenceInput) (*db.UserCompetence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if input.UserID == "" {
		return nil, errors.New("user id is required")
	}
	if input.CompetenceID == "" {
		return nil, errors.New("competence id is required")
	}

	userCompetence := db.UserCompetence{
		UserID:         input.UserID,
		Level:          input.Level,
		CreatedBy:      sql.NullString{String: currentUser.ID, Valid: true},
		CompetenceID:   input.CompetenceID,
		OrganisationID: currentUser.OrganisationID,
	}

	err = r.DB.NewInsert().Model(&userCompetence).Returning("*").Scan(ctx)

	if err != nil {
		return nil, err
	}

	return &userCompetence, nil
}

// ArchiveUserCompetence is the resolver for the archiveUserCompetence field.
func (r *mutationResolver) ArchiveUserCompetence(ctx context.Context, id string) (*db.UserCompetence, error) {
	panic(fmt.Errorf("not implemented: ArchiveUserCompetence - archiveUserCompetence"))
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// Check if tag with the same name already exists
	count, err := r.DB.NewSelect().Model(&db.Tag{}).Where("organisation_id = ?", currentUser.OrganisationID).Where("name = ?", input.Name).WhereAllWithDeleted().Count(ctx)
	if err != nil {
		return nil, err
	}

	if count > 0 {
		return nil, errors.New("Tag with the same name already exists")
	}

	// check if color is set
	color := input.Color
	if color == "" {
		color = "blue"
	}

	newTag := db.Tag{
		OrganisationID: currentUser.OrganisationID,
		Name:           input.Name,
		Color:          sql.NullString{String: color, Valid: true},
	}

	err = r.DB.NewInsert().Model(&newTag).Returning("*").Scan(ctx)

	if err != nil {
		return nil, err
	}

	return &newTag, nil
}

// ArchiveTag is the resolver for the archiveTag field.
func (r *mutationResolver) ArchiveTag(ctx context.Context, id string) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// set deleted_at field to the current time
	tag := db.Tag{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
		DeletedAt: bun.NullTime{
			Time: time.Now(),
		},
	}
	_, err = r.DB.NewUpdate().Model(&tag).Column("deleted_at").Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).WhereAllWithDeleted().Returning("*").Exec(ctx)

	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id string, input model.CreateTagInput) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var tag db.Tag
	tag.ID = id
	err = r.DB.NewSelect().
		Model(&tag).
		Where("organisation_id = ?", currentUser.OrganisationID).
		WherePK().
		Scan(ctx)

	if err != nil {
		return nil, err
	}

	// update the tag
	tag.Name = input.Name

	color := input.Color
	if color == "" {
		color = "blue"
	}

	tag.Color = sql.NullString{String: color, Valid: true}
	_, err = r.DB.NewUpdate().Model(&tag).WherePK().Exec(ctx)

	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	panic(fmt.Errorf("not implemented: UpdatePassword - updatePassword"))
}

// UpdateCompetence is the resolver for the updateCompetence field.
func (r *mutationResolver) UpdateCompetence(ctx context.Context, input model.UpdateCompetenceInput) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var competence db.Competence
	competence.ID = input.ID
	err = r.DB.NewSelect().
		Model(&competence).
		Where("organisation_id = ?", currentUser.OrganisationID).
		WherePK().
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	if input.Color != nil {
		competence.Color = sql.NullString{String: *input.Color, Valid: true}
	}

	err = r.DB.NewUpdate().Model(&competence).WherePK().Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// UpdateCompetenceSorting is the resolver for the updateCompetenceSorting field.
func (r *mutationResolver) UpdateCompetenceSorting(ctx context.Context, input model.UpdateCompetenceSortingInput) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	ids := make([]string, len(input.Competences))
	for i, id := range input.Competences {
		ids[i] = id.ID
	}

	var competences []*db.Competence
	err = r.DB.NewSelect().Model(&competences).Where("id IN (?)", bun.In(ids)).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// if length of competences is not equal to length of input, then some competences were not found
	if len(competences) != len(input.Competences) {
		return nil, fmt.Errorf("some competences were not found %v, %v", len(competences), len(input.Competences))
	}

	// create a map of competences for easy lookup
	competenceMap := make(map[string]*db.Competence)
	for _, competence := range competences {
		competenceMap[competence.ID] = competence
	}

	// update the sorting
	for i, id := range ids {
		competenceMap[id].SortOrder = i
	}

	for _, competence := range competences {
		sortOrder := competenceMap[competence.ID].SortOrder
		_, err = r.DB.NewUpdate().Model(competence).WherePK().Set("sort_order = ?", sortOrder).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	return competences, nil
}

// CreateCompetence is the resolver for the createCompetence field.
func (r *mutationResolver) CreateCompetence(ctx context.Context, input model.CreateCompetenceInput) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var subject db.Competence
	err = r.DB.NewSelect().Model(&subject).
		Where("id = ?", input.ParentID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("subject not found")
	}

	// grades with default array from 1-10
	defaultGrades := make([]int, 10)
	for i := 0; i < 10; i++ {
		defaultGrades[i] = i + 1
	}

	competence := db.Competence{
		CompetenceType: db.CompetenceTypeCompetence,
		CompetenceID:   sql.NullString{String: subject.ID, Valid: true},
		Name:           input.Name,
		Grades:         defaultGrades,
		OrganisationID: currentUser.OrganisationID,
		CreatedBy:      sql.NullString{String: currentUser.ID, Valid: true},
	}

	err = r.DB.NewInsert().Model(&competence).Returning("*").Scan(ctx)
	if err != nil {
		return nil, errors.New("creating competence failed")
	}

	return &competence, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput, search *string) (*model.UserConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	// query the users
	var users []*db.User
	query := r.DB.NewSelect().
		Model(&users).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(pageLimit).
		Offset(pageOffset)

	if filter != nil {
		if filter.Role != nil && len(filter.Role) > 0 {
			query.Where("role IN (?)", bun.In(filter.Role))
		}
		if filter.OrderBy != nil {
			switch *filter.OrderBy {
			case model.UserOrderByFirstNameAsc:
				query.OrderExpr("first_name ASC, last_name ASC")
			case model.UserOrderByFirstNameDesc:
				query.OrderExpr("first_name DESC, last_name DESC")
			case model.UserOrderByLastNameAsc:
				query.OrderExpr("last_name ASC, first_name ASC")
			case model.UserOrderByLastNameDesc:
				query.OrderExpr("last_name DESC, first_name DESC")
			default:
				query.OrderExpr("last_name ASC, first_name ASC")
			}
		}
		if filter.ShowDeleted != nil && *filter.ShowDeleted == true {
			query.WhereDeleted()
		}
	}

	if search != nil && *search != "" {
		withoutSpace := strings.Replace(*search, " ", "", -1)
		// TODO: refactor this
		query.Where("first_name ILIKE ? OR last_name ILIKE ? OR first_name || last_name ILIKE ? OR last_name || first_name ILIKE ?", "%"+withoutSpace+"%", "%"+withoutSpace+"%", "%"+withoutSpace+"%", "%"+withoutSpace+"%")
	}

	count, err := query.ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	return &model.UserConnection{
		Edges:      users,
		PageInfo:   pageInfo,
		TotalCount: count,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", currentUser.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Competence is the resolver for the competence field.
func (r *queryResolver) Competence(ctx context.Context, id string) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var competence db.Competence
	err = r.DB.NewSelect().Model(&competence).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// Competences is the resolver for the competences field.
func (r *queryResolver) Competences(ctx context.Context, limit *int, offset *int, filter *model.CompetenceFilterInput, search *string, sort *model.CompetenceSort) (*model.CompetenceConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var ids []string

	if search != nil && len(*search) > 0 {
		indexName := r.Meili.GetCompetenceIndex(currentUser.OrganisationID)
		filterStr := ""

		if filter != nil {
			if filter.Parents != nil && len(filter.Parents) > 0 {
				var parents []string
				for _, parent := range filter.Parents {
					parents = append(parents, *parent)

				}
				filterStr += "parents IN [" + strings.Join(parents, ", ") + "]"
			}

			// TODO: code repeats, find more elegant solution
			if filter.Type != nil && len(filter.Type) > 0 {
				var types []string
				for _, _type := range filter.Type {
					types = append(types, string(*_type))

				}
				filterStr += "competence_type IN [" + strings.Join(types, ", ") + "]"
			}
		}

		searchRequest := meilisearch.SearchRequest{
			Limit: int64(pageLimit),
		}

		if filterStr != "" {
			searchRequest.Filter = filterStr
		}

		term := *search

		response, err := r.Meili.Client.Index(indexName).SearchRaw(term, &searchRequest)
		if err != nil {
			return nil, err
		}

		var results meili.SearchResponseCompetence
		err = json.Unmarshal(*response, &results)
		if err != nil {
			return nil, err
		}

		for _, hit := range results.Hits {
			ids = append(ids, hit.ID)
		}

		fmt.Println(ids)
	}

	var competences []*db.Competence
	query := r.DB.NewSelect().
		Model(&competences).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(pageLimit).
		Offset(pageOffset)

	if len(ids) > 0 {
		query.Where("id IN (?)", bun.In(ids))
	} else {
		if sort != nil {
			query.Order("competence_type")
			switch sort.Field {
			case model.CompetenceSortFieldSortOrder:
				query.Order("sort_order ASC")
			case model.CompetenceSortFieldName:
				query.Order("name ASC")
			case model.CompetenceSortFieldCreatedAt:
				query.Order("created_at ASC")
			}
		} else {
			query.Order("competence_type")
			query.Order("name ASC")
		}

		if filter != nil {
			if filter.Type != nil {
				if len(filter.Type) == 1 {
					query.Where("competence_type = ?", filter.Type[0])
				} else {
					query.Where("competence_type IN (?)", bun.In(filter.Type))
				}
			}

			if filter.Parents != nil {
				if len(filter.Parents) == 1 {
					query.Where("competence_id = ?", filter.Parents[0])
				} else {
					query.Where("competence_id IN (?)", bun.In(filter.Parents))
				}
			}
		}
	}

	count, err := query.ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	page, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	page.CurrentPage = pageOffset / pageLimit
	return &model.CompetenceConnection{
		Edges:      competences,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var tag db.Tag
	err = r.DB.NewSelect().Model(&tag).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, limit *int, offset *int, search *string) (*model.TagConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var tags []*db.Tag
	query := r.DB.NewSelect().
		Model(&tags).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(pageLimit).
		Offset(pageOffset).
		Order("name")

	if search != nil && *search != "" {
		query.Where("name ILIKE ?", "%"+*search+"%")
	}

	count, err := query.ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	// Get the pageInfo
	page, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	return &model.TagConnection{
		Edges:      tags,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// UserStudents is the resolver for the userStudents field.
func (r *queryResolver) UserStudents(ctx context.Context, limit *int, offset *int) (*model.UserStudentConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var userStudents []*db.UserStudent
	count, err := r.DB.NewSelect().Model(&userStudents).Where("organisation_id = ?", currentUser.OrganisationID).Limit(pageLimit).Offset(pageOffset).ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	page, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	return &model.UserStudentConnection{
		Edges:      userStudents,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// UserStudent is the resolver for the userStudent field.
func (r *queryResolver) UserStudent(ctx context.Context, id string) (*db.UserStudent, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var userStudent db.UserStudent
	err = r.DB.NewSelect().Model(&userStudent).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// InviteDetails is the resolver for the inviteDetails field.
func (r *queryResolver) InviteDetails(ctx context.Context, token string) (*model.InviteDetailsPayload, error) {
	var user db.User
	err := r.DB.NewSelect().Model(&user).Where("recovery_token = ?", token).Scan(ctx)
	if err != nil {
		return nil, errors.New("invalid token")
	}

	if user.RecoverySentAt.Before(time.Now().Add(-time.Hour * 24)) {
		return nil, errors.New("token expired")
	}

	return &model.InviteDetailsPayload{
		Email:     user.Email.String,
		FirstName: user.FirstName,
		LastName:  user.LastName,
	}, nil
}

// Color is the resolver for the color field.
func (r *tagResolver) Color(ctx context.Context, obj *db.Tag) (string, error) {
	if obj.Color.Valid {
		return obj.Color.String, nil
	}

	return "", nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *tagResolver) DeletedAt(ctx context.Context, obj *db.Tag) (*time.Time, error) {
	if obj.DeletedAt.IsZero() {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// Email is the resolver for the email field.
func (r *userResolver) Email(ctx context.Context, obj *db.User) (*string, error) {
	if obj.Email.Valid {
		return &obj.Email.String, nil
	}

	return nil, nil
}

// Student is the resolver for the student field.
func (r *userResolver) Student(ctx context.Context, obj *db.User) (*db.UserStudent, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var userStudent db.UserStudent
	err = r.DB.NewSelect().Model(&userStudent).Where("user_id = ?", obj.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if obj.DeletedAt.IsZero() {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// InviteAccepted is the resolver for the inviteAccepted field.
func (r *userResolver) InviteAccepted(ctx context.Context, obj *db.User) (bool, error) {
	_, err := middleware.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	if obj.Password.Valid {
		return true, nil
	}

	return false, nil
}

// LastSeenAt is the resolver for the lastSeenAt field.
func (r *userResolver) LastSeenAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	randomTime := rand.Int63n(time.Now().Unix()-94608000) + 94608000
	randomNow := time.Unix(randomTime, 0)

	return &randomNow, nil
}

// Competence is the resolver for the competence field.
func (r *userCompetenceResolver) Competence(ctx context.Context, obj *db.UserCompetence) (*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var competence db.Competence
	err = r.DB.NewSelect().Model(&competence).Where("id = ?", obj.CompetenceID).Where("organisation_id = ?", currentUser.OrganisationID).WhereAllWithDeleted().Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// Entry is the resolver for the entry field.
func (r *userCompetenceResolver) Entry(ctx context.Context, obj *db.UserCompetence) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if sql.NullString(obj.EntryID).String == "" {
		return nil, nil
	}

	var entry db.Entry
	err = r.DB.NewSelect().Model(&entry).Where("id = ?", obj.EntryID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// User is the resolver for the user field.
func (r *userCompetenceResolver) User(ctx context.Context, obj *db.UserCompetence) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// CreatedBy is the resolver for the createdBy field.
func (r *userCompetenceResolver) CreatedBy(ctx context.Context, obj *db.UserCompetence) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", obj.CreatedBy).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// LeftAt is the resolver for the leftAt field.
func (r *userStudentResolver) LeftAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.LeftAt.IsZero() {
		return &obj.LeftAt.Time, nil
	}

	return nil, nil
}

// Birthday is the resolver for the birthday field.
func (r *userStudentResolver) Birthday(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.Birthday.IsZero() {
		return &obj.Birthday.Time, nil
	}
	return nil, nil
}

// Nationality is the resolver for the nationality field.
func (r *userStudentResolver) Nationality(ctx context.Context, obj *db.UserStudent) (*string, error) {
	panic(fmt.Errorf("not implemented: Nationality - nationality"))
}

// Comments is the resolver for the comments field.
func (r *userStudentResolver) Comments(ctx context.Context, obj *db.UserStudent) (*string, error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

// JoinedAt is the resolver for the joinedAt field.
func (r *userStudentResolver) JoinedAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.JoinedAt.IsZero() {
		return &obj.JoinedAt.Time, nil
	}

	return nil, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userStudentResolver) DeletedAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: DeletedAt - deletedAt"))
}

// EntriesCount is the resolver for the entriesCount field.
func (r *userStudentResolver) EntriesCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.NewSelect().Model(&db.EntryUser{}).Where("user_id = ?", obj.UserID).Where("organisation_id = ?", currentUser.OrganisationID).Count(ctx)

	if err != nil {
		return 0, err
	}

	return count, nil
}

// CompetencesCount is the resolver for the competencesCount field.
func (r *userStudentResolver) CompetencesCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.NewSelect().Model(&db.UserCompetence{}).Where("user_id = ?", obj.UserID).Where("organisation_id = ?", currentUser.OrganisationID).Count(ctx)

	if err != nil {
		return 0, err
	}

	return count, nil
}

// EventsCount is the resolver for the eventsCount field.
func (r *userStudentResolver) EventsCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.NewSelect().
		Model(&db.EntryEvent{}).
		Join("JOIN entry_users ON entry_users.entry_id = entry_event.entry_id").
		Where("entry_users.user_id = ?", obj.UserID).
		Where("entry_event.organisation_id = ?", currentUser.OrganisationID).
		Count(ctx)

	if err != nil {
		return 0, err
	}

	return count, nil
}

// Emoji is the resolver for the emoji field.
func (r *userStudentResolver) Emoji(ctx context.Context, obj *db.UserStudent) (*string, error) {
	_, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if obj.Emoji.Valid {
		return &obj.Emoji.String, nil
	}
	return nil, nil
}

// User is the resolver for the user field.
func (r *userStudentResolver) User(ctx context.Context, obj *db.UserStudent) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// Competence returns CompetenceResolver implementation.
func (r *Resolver) Competence() CompetenceResolver { return &competenceResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Tag returns TagResolver implementation.
func (r *Resolver) Tag() TagResolver { return &tagResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// UserCompetence returns UserCompetenceResolver implementation.
func (r *Resolver) UserCompetence() UserCompetenceResolver { return &userCompetenceResolver{r} }

// UserStudent returns UserStudentResolver implementation.
func (r *Resolver) UserStudent() UserStudentResolver { return &userStudentResolver{r} }

type competenceResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userCompetenceResolver struct{ *Resolver }
type userStudentResolver struct{ *Resolver }
