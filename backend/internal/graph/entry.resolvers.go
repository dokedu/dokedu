package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"mime"
	"path/filepath"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/dokedu/dokedu/backend/internal/msg"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/minio/minio-go/v7"
	"github.com/samber/lo"
)

// Date is the resolver for the date field.
func (r *entryResolver) Date(ctx context.Context, obj *db.Entry) (string, error) {
	panic(fmt.Errorf("not implemented: Date - date"))
}

// User is the resolver for the user field.
func (r *entryResolver) User(ctx context.Context, obj *db.Entry) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, msg.ErrUnauthenticated
	}

	user, err := r.DB.UserById(ctx, db.UserByIdParams{
		ID:             obj.UserID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get user")
	}

	return &user, nil
}

// Users is the resolver for the users field.
func (r *entryResolver) Users(ctx context.Context, obj *db.Entry) ([]*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	users, err := r.DB.UserListByEntryUserByEntryId(ctx, db.UserListByEntryUserByEntryIdParams{
		EntryID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get users")
	}

	return lo.ToSlicePtr(users), nil
}

// Events is the resolver for the events field.
func (r *entryResolver) Events(ctx context.Context, obj *db.Entry) ([]*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	events, err := r.DB.EventListByEntryEventByEntryId(ctx, db.EventListByEntryEventByEntryIdParams{
		EntryID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get events")
	}

	return lo.ToSlicePtr(events), nil
}

// Files is the resolver for the files field.
func (r *entryResolver) Files(ctx context.Context, obj *db.Entry) ([]*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	files, err := r.DB.FileListByEntryFileByEntryId(ctx, db.FileListByEntryFileByEntryIdParams{
		EntryID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get files")
	}

	return lo.ToSlicePtr(files), nil
}

// Tags is the resolver for the tags field.
func (r *entryResolver) Tags(ctx context.Context, obj *db.Entry) ([]*db.Tag, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	tags, err := r.DB.TagListByEntryTagByEntryId(ctx, db.TagListByEntryTagByEntryIdParams{
		EntryID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get tags")
	}

	return lo.ToSlicePtr(tags), nil
}

// UserCompetences is the resolver for the userCompetences field.
func (r *entryResolver) UserCompetences(ctx context.Context, obj *db.Entry) ([]*db.UserCompetence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	userCompetences, err := r.DB.UserCompetenceListByEntryId(ctx, db.UserCompetenceListByEntryIdParams{
		EntryID:        pgtype.Text{String: obj.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get user competences")
	}

	return lo.ToSlicePtr(userCompetences), nil
}

// Subjects is the resolver for the subjects field.
func (r *entryResolver) Subjects(ctx context.Context, obj *db.Entry) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	userCompetences, err := r.DB.UserCompetenceListByEntryId(ctx, db.UserCompetenceListByEntryIdParams{
		EntryID:        pgtype.Text{String: obj.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get user competences")
	}

	var competenceIDs []string
	for _, uc := range userCompetences {
		competenceIDs = append(competenceIDs, uc.CompetenceID)
	}

	competences, err := r.DB.CompetenceList(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, errors.New("failed to get competences")
	}

	var subjects []*db.Competence

	// TODO: this might not work and also requires performance improvements,
	//  ideally we cache the competences of each organisation in memory
	//  or we store the parents as path in the database as extra column for each competence
	for _, uc := range userCompetences {
		competence, ok := helper.FindCompetenceById(competences, uc.CompetenceID)
		if !ok {
			return nil, errors.New("failed to get competence")
		}
		subject, ok := helper.FindCompetenceParent(competences, competence)
		if !ok {
			return nil, errors.New("failed to get subject")
		}
		subjects = append(subjects, &subject)
	}

	return subjects, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *entryResolver) DeletedAt(ctx context.Context, obj *db.Entry) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}
	return nil, nil
}

// CreateEntry is the resolver for the createEntry field.
func (r *mutationResolver) CreateEntry(ctx context.Context) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.CreateEntry(ctx, db.CreateEntryParams{
		Body:           "",
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to create entry")
	}

	return &entry, nil
}

// UpdateEntry is the resolver for the updateEntry field.
func (r *mutationResolver) UpdateEntry(ctx context.Context, input model.UpdateEntryInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var entry db.Entry
	entry.ID = input.ID

	query := r.DB.NewQueryBuilder().
		Update("entries").
		Where("organisation_id = ?", currentUser.OrganisationID).
		Where("id = ?", input.ID).
		Suffix("RETURNING *")

	if input.Date != nil {
		d, err := time.Parse("2006-01-02", *input.Date)
		if err != nil {
			return nil, errors.New("failed to parse date")
		}
		entry.Date = pgtype.Date{Time: d, Valid: true}
		query.Set("date", entry.Date)
	}

	if input.Body != nil {
		entry.Body = *input.Body
		query = query.Set("body", entry.Body)
	}

	err = query.Scan(ctx)
	if err != nil {
		return nil, errors.New("failed to update entry")
	}

	return &entry, nil
}

// ArchiveEntry is the resolver for the archiveEntry field.
func (r *mutationResolver) ArchiveEntry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// set deleted_at field to the current time
	entry, err := r.DB.DeleteEntry(ctx, db.DeleteEntryParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to archive entry")
	}

	return &entry, nil
}

// CreateEntryTag is the resolver for the createEntryTag field.
func (r *mutationResolver) CreateEntryTag(ctx context.Context, input model.CreateEntryTagInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	tag, err := r.DB.TagById(ctx, db.TagByIdParams{
		ID:             input.TagID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.CreateEntryTag(ctx, db.CreateEntryTagParams{
		EntryID:        entry.ID,
		TagID:          tag.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to create entry tag")
	}

	return &entry, nil
}

// CreateEntryFile is the resolver for the createEntryFile field.
func (r *mutationResolver) CreateEntryFile(ctx context.Context, input model.CreateEntryFileInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get entry")
	}

	file, err := r.DB.FileById(ctx, db.FileByIdParams{
		ID:             input.FileID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get file")
	}

	_, err = r.DB.CreateEntryFile(ctx, db.CreateEntryFileParams{
		EntryID:        entry.ID,
		FileID:         file.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to create entry file")
	}

	return &entry, nil
}

// CreateEntryUser is the resolver for the createEntryUser field.
func (r *mutationResolver) CreateEntryUser(ctx context.Context, input model.CreateEntryUserInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get entry")
	}

	user, err := r.DB.UserById(ctx, db.UserByIdParams{
		ID:             input.UserID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.CreateEntryUser(ctx, db.CreateEntryUserParams{
		EntryID:        entry.ID,
		UserID:         user.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to create entry user")
	}

	// user competences for entry
	userCompetence, err := r.DB.CompetenceListByUserCompetenceByEntry(ctx, db.CompetenceListByUserCompetenceByEntryParams{
		EntryID:        pgtype.Text{String: entry.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to get user competences")
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	// TODO: this might not work and also requires performance improvements
	for _, uc := range userCompetence {
		_, err = qtx.UpsertUserCompetence(ctx, db.UpsertUserCompetenceParams{
			EntryID:        pgtype.Text{String: entry.ID, Valid: true},
			OrganisationID: currentUser.OrganisationID,
			CompetenceID:   uc.CompetenceID.String,
			Level:          1,
			UserID:         user.ID,
		})
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// CreateEntryEvent is the resolver for the createEntryEvent field.
func (r *mutationResolver) CreateEntryEvent(ctx context.Context, input model.CreateEntryEventInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	event, err := r.DB.EventById(ctx, db.EventByIdParams{
		ID:             input.EventID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.CreateEntryEvent(ctx, db.CreateEntryEventParams{
		EntryID:        entry.ID,
		EventID:        event.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// CreateEntryCompetence is the resolver for the createEntryCompetence field.
func (r *mutationResolver) CreateEntryCompetence(ctx context.Context, input model.CreateEntryCompetenceInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	competence, err := r.DB.CompetenceById(ctx, db.CompetenceByIdParams{
		ID:             input.CompetenceID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	users, err := r.DB.UserListByEntryUserByEntryId(ctx, db.UserListByEntryUserByEntryIdParams{
		EntryID:        entry.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	for _, user := range users {
		_, err = qtx.UpsertUserCompetence(ctx, db.UpsertUserCompetenceParams{
			EntryID:        pgtype.Text{String: entry.ID, Valid: true},
			OrganisationID: currentUser.OrganisationID,
			CompetenceID:   competence.ID,
			Level:          1,
			UserID:         user.ID,
		})
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// DeleteEntryTag is the resolver for the deleteEntryTag field.
func (r *mutationResolver) DeleteEntryTag(ctx context.Context, input model.DeleteEntryTagInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.DeleteEntryTag(ctx, db.DeleteEntryTagParams{
		EntryID:        input.EntryID,
		TagID:          input.TagID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// DeleteEntryFile is the resolver for the deleteEntryFile field.
func (r *mutationResolver) DeleteEntryFile(ctx context.Context, input model.DeleteEntryFileInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.DeleteEntryFile(ctx, db.DeleteEntryFileParams{
		EntryID: input.EntryID,
		FileID:  input.FileID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// DeleteEntryUser is the resolver for the deleteEntryUser field.
func (r *mutationResolver) DeleteEntryUser(ctx context.Context, input model.DeleteEntryUserInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	_, err = qtx.DeleteEntryUser(ctx, db.DeleteEntryUserParams{
		EntryID: input.EntryID,
		UserID:  input.UserID,
	})
	if err != nil {
		return nil, err
	}

	_, err = qtx.DeleteUserCompetences(ctx, db.DeleteUserCompetencesParams{
		EntryID:        pgtype.Text{String: entry.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
		UserID:         input.UserID,
	})
	if err != nil {
		return nil, err
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// DeleteEntryEvent is the resolver for the deleteEntryEvent field.
func (r *mutationResolver) DeleteEntryEvent(ctx context.Context, input model.DeleteEntryEventInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.DeleteEntryEvent(ctx, db.DeleteEntryEventParams{
		EntryID:        input.EntryID,
		EventID:        input.EventID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// DeleteEntryCompetence is the resolver for the deleteEntryCompetence field.
func (r *mutationResolver) DeleteEntryCompetence(ctx context.Context, input model.DeleteEntryCompetenceInput) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.DeleteEntryCompetences(ctx, db.DeleteEntryCompetencesParams{
		EntryID:        pgtype.Text{String: entry.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// UpdateEntryUserCompetenceLevel is the resolver for the updateEntryUserCompetenceLevel field.
func (r *mutationResolver) UpdateEntryUserCompetenceLevel(ctx context.Context, input model.UpdateEntryUserCompetenceLevel) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	_, err = r.DB.UpdateUserCompetenceLevels(ctx, db.UpdateUserCompetenceLevelsParams{
		Level:          int32(input.Level),
		CompetenceID:   input.CompetenceID,
		EntryID:        pgtype.Text{String: entry.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// UploadFileToEntry is the resolver for the uploadFileToEntry field.
func (r *mutationResolver) UploadFileToEntry(ctx context.Context, entryID string, file graphql.Upload) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             entryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	var uploadFile db.File
	uploadFile.Name = file.Filename
	uploadFile.FileType = "blob"
	uploadFile.OrganisationID = currentUser.OrganisationID
	uploadFile.Size = file.Size

	mimeFileType := mime.TypeByExtension(filepath.Ext(file.Filename))
	uploadFile.MimeType = pgtype.Text{String: mimeFileType, Valid: true}

	bucket, err := r.DB.InternalBucketByName(ctx, db.InternalBucketByNameParams{
		Name:           "entries",
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		//	create bucket
		_, err = r.DB.CreateInternalBucket(ctx, db.CreateInternalBucketParams{
			Name:           "entries",
			Shared:         false,
			OrganisationID: currentUser.OrganisationID,
		})
		if err != nil {
			return nil, errors.New("failed to create bucket")
		}

		err = r.MinioClient.MakeBucket(ctx, bucket.ID, minio.MakeBucketOptions{})
		if err != nil {
			return nil, errors.New("failed to create minio bucket")
		}
	}
	if err != nil {
		return nil, errors.New("failed to find bucket")
	}

	uploadFile, err = r.DB.CreateFile(ctx, db.CreateFileParams{
		Name:           uploadFile.Name,
		MimeType:       uploadFile.MimeType,
		FileType:       uploadFile.FileType,
		BucketID:       bucket.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to save file")
	}

	_, err = r.DB.CreateEntryFile(ctx, db.CreateEntryFileParams{
		EntryID:        entry.ID,
		FileID:         uploadFile.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to create entry file")
	}

	// Upload the file to specific bucket with the file id
	_, err = r.MinioClient.PutObject(ctx, bucket.ID, uploadFile.ID, file.File, uploadFile.Size, minio.PutObjectOptions{
		ContentType: file.ContentType,
	})
	if err != nil {
		return nil, errors.New("failed to upload file")
	}

	return &entry, nil
}

// RemoveFileFromEntry is the resolver for the removeFileFromEntry field.
func (r *mutationResolver) RemoveFileFromEntry(ctx context.Context, entryID string, fileID string) (*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entryFile, err := r.DB.DeleteEntryFile(ctx, db.DeleteEntryFileParams{
		EntryID:        entryID,
		FileID:         fileID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("failed to delete file from entry")
	}

	file, err := r.DB.FileById(ctx, db.FileByIdParams{
		ID:             entryFile.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("file not found")
	}

	return &file, nil
}

// Entry is the resolver for the entry field.
func (r *queryResolver) Entry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	entry, err := r.DB.EntryById(ctx, db.EntryByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// Entries is the resolver for the entries field.
func (r *queryResolver) Entries(ctx context.Context, limit *int, offset *int, filter *model.EntryFilterInput, sortBy *model.EntrySortBy, search *string) (*model.EntryConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var entries []*db.Entry

	query := r.DB.NewQueryBuilder().Select("*").
		From("entries").
		Join("LEFT JOIN entry_users eu ON entries.id = eu.entry_id").
		Where("eu.deleted_at IS NULL").
		Join("LEFT JOIN entry_tags et ON entries.id = et.entry_id").
		Where("et.deleted_at IS NULL").
		Where("entries.organisation_id = ?", currentUser.OrganisationID).
		Limit(uint64(pageLimit)).
		Offset(uint64(pageOffset))

	if filter != nil {
		if filter.Users != nil && len(filter.Users) > 0 {
			query.Where("eu.user_id = ANY(?)", filter.Users)
		}
		if filter.Authors != nil && len(filter.Authors) > 0 {
			query.Where("entries.user_id = ANY(?)", filter.Authors)
		}
		if filter.Tags != nil && len(filter.Tags) > 0 {
			query.Where("et.tag_id = ANY(?)", filter.Tags)
			query.Where("(SELECT COUNT(DISTINCT et2.tag_id) FROM entry_tags et2 WHERE et2.entry_id = entries.id) >= ?", len(filter.Tags))
		}
	}

	if sortBy != nil {
		switch *sortBy {
		case model.EntrySortByCreatedAtAsc:
			query.OrderBy("entries.created_at ASC")
		case model.EntrySortByCreatedAtDesc:
			query.OrderBy("entries.created_at DESC")
		case model.EntrySortByDateAsc:
			query.OrderBy("entries.date ASC")
		case model.EntrySortByDateDesc:
			query.OrderBy("entries.date DESC")
		default:
			query.OrderBy("entries.created_at DESC")
		}
	}

	err = query.Scan(entries)
	if err != nil {
		return nil, err
	}

	// TODO: this is a placeholder, we need to implement the count!!!
	count := 10_000

	// Page info
	page, err := helper.CreatePageInfo(pageLimit, pageOffset, count)
	if err != nil {
		return nil, err
	}

	page.CurrentPage = pageOffset / pageLimit
	return &model.EntryConnection{
		Edges:      entries,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// Entry returns EntryResolver implementation.
func (r *Resolver) Entry() EntryResolver { return &entryResolver{r} }

type entryResolver struct{ *Resolver }
