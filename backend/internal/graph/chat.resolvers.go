package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/dokedu/dokedu/backend/internal/msg"
	"github.com/jackc/pgx/v5/pgtype"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/dataloaders"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/samber/lo"
	"github.com/uptrace/bun"
)

// Name is the resolver for the name field.
func (r *chatResolver) Name(ctx context.Context, obj *db.Chat) (*string, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if obj.Type.Valid && obj.Type.ChatType == db.ChatTypePrivate {
		user, err := r.DB.ChatNameWithAuthByChatId(ctx, db.ChatNameWithAuthByChatIdParams{
			ChatID:         obj.ID,
			UserID:         currentUser.ID,
			OrganisationID: currentUser.OrganisationID,
		})

		if err != nil {
			return nil, err
		}

		fullName := user.FirstName + " " + user.LastName

		return &fullName, nil
	}

	return &obj.Name.String, nil
}

// Users is the resolver for the users field.
func (r *chatResolver) Users(ctx context.Context, obj *db.Chat) ([]*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	users, err := r.DB.UserListByChatId(ctx, db.UserListByChatIdParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	return lo.ToSlicePtr(users), err
}

// Type is the resolver for the type field.
func (r *chatResolver) Type(ctx context.Context, obj *db.Chat) (db.ChatType, error) {
	return obj.Type.ChatType, nil
}

// Messages is the resolver for the messages field.
func (r *chatResolver) Messages(ctx context.Context, obj *db.Chat) ([]*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	messages, err := r.DB.ChatMessageListByChatId(ctx, db.ChatMessageListByChatIdParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	return lo.ToSlicePtr(messages), err
}

// LastMessage is the resolver for the lastMessage field.
func (r *chatResolver) LastMessage(ctx context.Context, obj *db.Chat) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chatMessage, err := r.DB.LastChatMessage(ctx, db.LastChatMessageParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &chatMessage, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *chatResolver) DeletedAt(ctx context.Context, obj *db.Chat) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: DeletedAt - deletedAt"))
}

// UnreadMessageCount is the resolver for the unreadMessageCount field.
func (r *chatResolver) UnreadMessageCount(ctx context.Context, obj *db.Chat) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	chatMessageViewCount, err := r.DB.UnreadMessageCount(ctx, db.UnreadMessageCountParams{
		ChatID:         obj.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return 0, errors.New("unable to get unread message count")
	}

	return int(chatMessageViewCount), nil
}

// UserCount is the resolver for the userCount field.
func (r *chatResolver) UserCount(ctx context.Context, obj *db.Chat) (int, error) {
	count, err := r.DB.UserCountByChatId(ctx, db.UserCountByChatIdParams{
		ChatID:         obj.ID,
		OrganisationID: obj.OrganisationID,
	})
	return int(count), err
}

// Chat is the resolver for the chat field.
func (r *chatMessageResolver) Chat(ctx context.Context, obj *db.ChatMessage) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.ChatById(ctx, db.ChatByIdParams{
		ID:             obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &chat, err
}

// User is the resolver for the user field.
func (r *chatMessageResolver) User(ctx context.Context, obj *db.ChatMessage) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// IsEdited is the resolver for the isEdited field.
func (r *chatMessageResolver) IsEdited(ctx context.Context, obj *db.ChatMessage) (bool, error) {
	return obj.UpdatedAt.Valid, nil
}

// IsSeen is the resolver for the isSeen field.
func (r *chatMessageResolver) IsSeen(ctx context.Context, obj *db.ChatMessage) (bool, error) {
	messageView, err := dataloaders.GetChatMessageView(ctx, obj.ID)
	if err != nil {
		return false, err
	}
	if messageView == nil {
		return false, nil
	}

	return true, nil
}

// Chat is the resolver for the chat field.
func (r *chatUserResolver) Chat(ctx context.Context, obj *db.ChatUser) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.ChatById(ctx, db.ChatByIdParams{
		ID:             obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &chat, err
}

// User is the resolver for the user field.
func (r *chatUserResolver) User(ctx context.Context, obj *db.ChatUser) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, input model.CreateChatInput) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, msg.ErrUnauthorized
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	chat, err := qtx.CreateChat(ctx, db.CreateChatParams{
		Name:           pgtype.Text{String: *input.Name, Valid: true},
		Type:           db.NullChatType{ChatType: db.ChatTypeGroup, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})

	_, err = qtx.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         chat.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// DeleteChat is the resolver for the deleteChat field.
func (r *mutationResolver) DeleteChat(ctx context.Context, input model.DeleteChatInput) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, msg.ErrUnauthorized
	}

	chat, err := r.DB.DeleteChat(ctx, db.DeleteChatParams{
		ID:             input.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &chat, err
}

// CreatePrivatChat is the resolver for the createPrivatChat field.
func (r *mutationResolver) CreatePrivatChat(ctx context.Context, userID string) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check if a privat chat already exists
	existingChat, err := r.DB.ExistingChatBetweenTwoUsers(ctx, db.ExistingChatBetweenTwoUsersParams{
		UserID:         currentUser.ID,
		OtherUserID:    userID,
		ChatType:       db.NullChatType{ChatType: db.ChatTypePrivate, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err == nil {
		return &existingChat, nil
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	user, err := qtx.UserById(ctx, db.UserByIdParams{
		ID:             userID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("user not found")
	}

	newChat, err := qtx.CreateChat(ctx, db.CreateChatParams{
		Name:           pgtype.Text{},
		Type:           db.NullChatType{ChatType: db.ChatTypePrivate, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to create chat")
	}

	_, err = qtx.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         newChat.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to add user to chat")
	}

	_, err = qtx.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         newChat.ID,
		UserID:         user.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to add other user to chat")
	}

	err = tx.Commit(ctx)

	return &newChat, nil
}

// AddUserToChat is the resolver for the addUserToChat field.
func (r *mutationResolver) AddUserToChat(ctx context.Context, input model.AddUserToChatInput) (*db.ChatUser, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if input.UserID == currentUser.ID {
		return nil, errors.New("you cannot add yourself to a chat")
	}

	var chat db.Chat
	err = r.DB.NewSelect().
		Model(&chat).
		Where("chat.id = ?", input.ChatID).
		Join("INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	var user db.User
	err = r.DB.NewSelect().
		Model(&user).
		Where("id = ?", input.UserID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if errors.Is(err, sql.ErrNoRows) {
		return nil, errors.New("user not found")
	}
	if err != nil {
		return nil, err
	}

	var chatUser3 db.ChatUser
	chatUser3.ChatID = input.ChatID
	chatUser3.UserID = input.UserID
	chatUser3.OrganisationID = currentUser.OrganisationID

	err = r.DB.NewInsert().
		Model(&chatUser3).
		Returning("*").
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &chatUser3, nil
}

// RemoveUserFromChat is the resolver for the removeUserFromChat field.
func (r *mutationResolver) RemoveUserFromChat(ctx context.Context, input model.RemoveUserFromChatInput) (*db.ChatUser, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var chat db.Chat
	err = r.DB.NewSelect().
		Model(&chat).
		Where("chat.id = ?", input.ChatID).
		Join("INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	var chatUser db.ChatUser
	err = r.DB.NewDelete().
		Model(&chatUser).
		Where("chat_id = ?", input.ChatID).
		Where("user_id = ?", input.UserID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &chatUser, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check that the message is less than 4096 characters
	if len(input.Message) > 4096 {
		return nil, errors.New("message too long, max 4096 characters")
	}

	var chat db.Chat
	err = r.DB.NewSelect().
		Model(&chat).
		Where("chat.id = ?", input.ChatID).
		Join("INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	var chatMessage db.ChatMessage
	chatMessage.ChatID = input.ChatID
	chatMessage.UserID = currentUser.ID
	chatMessage.OrganisationID = currentUser.OrganisationID
	chatMessage.Message = input.Message
	chatMessage.CreatedAt = time.Now()

	err = r.DB.NewInsert().
		Model(&chatMessage).
		Returning("*").
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	// background handling of sending message to other users
	go r.SubscriptionHandler.PublishMessage(&chatMessage)
	go r.ChatMessageProcessor.NewMessage(chatMessage)

	return &chatMessage, nil
}

// EditChatMessage is the resolver for the editChatMessage field.
func (r *mutationResolver) EditChatMessage(ctx context.Context, input model.EditChatMessageInput) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var chatMessage db.ChatMessage
	err = r.DB.NewSelect().
		Model(&chatMessage).
		Where("id = ?", input.ID).
		Where("user_id = ?", currentUser.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("message not found")
	}

	// check that the message is less than 4096 characters
	if len(input.Message) > 4096 {
		return nil, errors.New("message too long, max 4096 characters")
	}

	chatMessage.Message = input.Message
	chatMessage.UpdatedAt = bun.NullTime{Time: time.Now()}

	err = r.DB.NewUpdate().
		Model(&chatMessage).
		Where("id = ?", input.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		Scan(ctx)
	if err != nil {
		return nil, errors.New("unable to update message")
	}

	go r.SubscriptionHandler.PublishMessage(&chatMessage)

	return &chatMessage, nil
}

// UpdateChat is the resolver for the updateChat field.
func (r *mutationResolver) UpdateChat(ctx context.Context, input model.UpdateChatInput) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var chat db.Chat
	err = r.DB.NewSelect().
		Model(&chat).
		Where("chat.id = ?", input.ID).
		Join("INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	chat.Name = sql.NullString{
		String: *input.Name,
		Valid:  true,
	}

	err = r.DB.NewUpdate().
		Model(&chat).
		Where("id = ?", input.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// MarkMessageAsRead is the resolver for the markMessageAsRead field.
func (r *mutationResolver) MarkMessageAsRead(ctx context.Context, messageID string) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var chatMessage db.ChatMessage
	err = r.DB.NewSelect().
		Model(&chatMessage).
		Where("id = ?", messageID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	var chat db.Chat
	err = r.DB.NewSelect().
		Model(&chat).
		Where("chat.id = ?", chatMessage.ChatID).
		Join("INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	var chatMessageView db.ChatMessageView
	chatMessageView.ChatID = chat.ID
	chatMessageView.UserID = currentUser.ID
	chatMessageView.ChatMessageID = chatMessage.ID
	chatMessageView.OrganisationID = currentUser.OrganisationID
	err = r.DB.NewInsert().
		Model(&chatMessageView).
		Returning("*").
		On("CONFLICT (chat_id, user_id, chat_message_id) DO NOTHING").
		Scan(ctx)
	if errors.Is(err, sql.ErrNoRows) {
		return &chatMessage, nil
	}
	if err != nil {
		return nil, errors.New("unable to mark message as read")
	}

	return &chatMessage, nil
}

// Chat is the resolver for the chat field.
func (r *queryResolver) Chat(ctx context.Context, id string) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var chat db.Chat
	err = r.DB.NewSelect().
		Model(&chat).
		Where("chat.id = ?", id).
		Join("INNER JOIN chat_users ON chat_users.chat_id = chat.id AND chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Scan(ctx)
	if err != nil {
		return nil, errors.New("chat not found")
	}

	return &chat, nil
}

// Chats is the resolver for the chats field.
func (r *queryResolver) Chats(ctx context.Context, limit *int, offset *int) (*model.ChatConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var count int
	var chats []*db.ChatWithLastMessage
	count, err = r.DB.
		NewSelect().
		Model(&chats).
		ColumnExpr("chat.*").
		ColumnExpr("MAX(cm.created_at) as last_message_at").
		Join("LEFT JOIN chat_users ON chat_users.chat_id = chat.id").
		Join("LEFT JOIN chat_messages cm ON cm.chat_id = chat.id").
		TableExpr("chats AS chat").
		Where("chat_users.user_id = ?", currentUser.ID).
		Where("chat.organisation_id = ?", currentUser.OrganisationID).
		Where("chat.deleted_at IS NULL").
		Limit(pageLimit).
		Offset(pageOffset).
		Group("chat.id").
		OrderExpr("CASE WHEN MAX(cm.created_at) IS NULL THEN 1 ELSE 0 END").
		Order("last_message_at DESC").
		ScanAndCount(ctx)
	if errors.Is(err, sql.ErrNoRows) {
		return &model.ChatConnection{}, nil
	}
	if err != nil {
		return nil, err
	}

	pageInfo, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	var returnChats []*db.Chat
	for _, chat := range chats {
		returnChats = append(returnChats, chat.Chat)
	}

	return &model.ChatConnection{
		Edges:      returnChats,
		TotalCount: count,
		PageInfo:   pageInfo,
	}, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context) (<-chan *db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	_ = r.SubscriptionHandler.AddUserChannel(currentUser.ID)

	channel := r.SubscriptionHandler.UserChannel[currentUser.ID][len(r.SubscriptionHandler.UserChannel[currentUser.ID])-1]

	go func() {
		<-ctx.Done()
		_ = r.SubscriptionHandler.RemoveChatChannel(currentUser.ID, channel)
	}()

	return channel, nil
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// ChatMessage returns ChatMessageResolver implementation.
func (r *Resolver) ChatMessage() ChatMessageResolver { return &chatMessageResolver{r} }

// ChatUser returns ChatUserResolver implementation.
func (r *Resolver) ChatUser() ChatUserResolver { return &chatUserResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type chatResolver struct{ *Resolver }
type chatMessageResolver struct{ *Resolver }
type chatUserResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
