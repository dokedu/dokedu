package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/dokedu/dokedu/backend/internal/msg"
	"github.com/jackc/pgx/v5/pgtype"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/dataloaders"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/samber/lo"
)

// Name is the resolver for the name field.
func (r *chatResolver) Name(ctx context.Context, obj *db.Chat) (*string, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	if obj.Type.Valid && obj.Type.ChatType == db.ChatTypePrivate {
		user, err := r.DB.ChatNameWithAuthByChatId(ctx, db.ChatNameWithAuthByChatIdParams{
			ChatID:         obj.ID,
			UserID:         currentUser.ID,
			OrganisationID: currentUser.OrganisationID,
		})
		if err != nil {
			return nil, err
		}

		fullName := user.FirstName + " " + user.LastName

		return &fullName, nil
	}

	return &obj.Name.String, nil
}

// Users is the resolver for the users field.
func (r *chatResolver) Users(ctx context.Context, obj *db.Chat) ([]*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	users, err := r.DB.UserListByChatId(ctx, db.UserListByChatIdParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})

	return lo.ToSlicePtr(users), err
}

// Type is the resolver for the type field.
func (r *chatResolver) Type(ctx context.Context, obj *db.Chat) (db.ChatType, error) {
	return obj.Type.ChatType, nil
}

// Messages is the resolver for the messages field.
func (r *chatResolver) Messages(ctx context.Context, obj *db.Chat) ([]*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	messages, err := r.DB.ChatMessageListByChatId(ctx, db.ChatMessageListByChatIdParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	return lo.ToSlicePtr(messages), err
}

// LastMessage is the resolver for the lastMessage field.
func (r *chatResolver) LastMessage(ctx context.Context, obj *db.Chat) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chatMessage, err := r.DB.LastChatMessage(ctx, db.LastChatMessageParams{
		ChatID:         obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &chatMessage, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *chatResolver) DeletedAt(ctx context.Context, obj *db.Chat) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: DeletedAt - deletedAt"))
}

// UnreadMessageCount is the resolver for the unreadMessageCount field.
func (r *chatResolver) UnreadMessageCount(ctx context.Context, obj *db.Chat) (int, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	chatMessageViewCount, err := r.DB.UnreadMessageCount(ctx, db.UnreadMessageCountParams{
		ChatID:         obj.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return 0, errors.New("unable to get unread message count")
	}

	return int(chatMessageViewCount), nil
}

// UserCount is the resolver for the userCount field.
func (r *chatResolver) UserCount(ctx context.Context, obj *db.Chat) (int, error) {
	_, err := middleware.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	count, err := r.DB.UserCountByChatId(ctx, db.UserCountByChatIdParams{
		ChatID:         obj.ID,
		OrganisationID: obj.OrganisationID,
	})
	return int(count), err
}

// Chat is the resolver for the chat field.
func (r *chatMessageResolver) Chat(ctx context.Context, obj *db.ChatMessage) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.ChatById(ctx, db.ChatByIdParams{
		ID:             obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &chat, err
}

// User is the resolver for the user field.
func (r *chatMessageResolver) User(ctx context.Context, obj *db.ChatMessage) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// IsEdited is the resolver for the isEdited field.
func (r *chatMessageResolver) IsEdited(ctx context.Context, obj *db.ChatMessage) (bool, error) {
	return obj.UpdatedAt.Valid, nil
}

// IsSeen is the resolver for the isSeen field.
func (r *chatMessageResolver) IsSeen(ctx context.Context, obj *db.ChatMessage) (bool, error) {
	messageView, err := dataloaders.GetChatMessageView(ctx, obj.ID)
	if err != nil {
		return false, err
	}
	if messageView == nil {
		return false, nil
	}

	return true, nil
}

// Chat is the resolver for the chat field.
func (r *chatUserResolver) Chat(ctx context.Context, obj *db.ChatUser) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.ChatById(ctx, db.ChatByIdParams{
		ID:             obj.ChatID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &chat, err
}

// User is the resolver for the user field.
func (r *chatUserResolver) User(ctx context.Context, obj *db.ChatUser) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return dataloaders.GetUser(ctx, obj.UserID, currentUser)
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, input model.CreateChatInput) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	chat, err := qtx.CreateChat(ctx, db.CreateChatParams{
		Name:           pgtype.Text{String: *input.Name, Valid: true},
		Type:           db.NullChatType{ChatType: db.ChatTypeGroup, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})

	_, err = qtx.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         chat.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, err
	}

	return &chat, nil
}

// DeleteChat is the resolver for the deleteChat field.
func (r *mutationResolver) DeleteChat(ctx context.Context, input model.DeleteChatInput) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.DeleteChat(ctx, db.DeleteChatParams{
		ID:             input.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &chat, err
}

// CreatePrivatChat is the resolver for the createPrivatChat field.
func (r *mutationResolver) CreatePrivatChat(ctx context.Context, userID string) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check if a privat chat already exists
	existingChat, err := r.DB.ExistingChatBetweenTwoUsers(ctx, db.ExistingChatBetweenTwoUsersParams{
		UserID:         currentUser.ID,
		OtherUserID:    userID,
		ChatType:       db.NullChatType{ChatType: db.ChatTypePrivate, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err == nil {
		return &existingChat, nil
	}

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	user, err := qtx.UserById(ctx, db.UserByIdParams{
		ID:             userID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("user not found")
	}

	newChat, err := qtx.CreateChat(ctx, db.CreateChatParams{
		Name:           pgtype.Text{},
		Type:           db.NullChatType{ChatType: db.ChatTypePrivate, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to create chat")
	}

	_, err = qtx.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         newChat.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to add user to chat")
	}

	_, err = qtx.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         newChat.ID,
		UserID:         user.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to add other user to chat")
	}

	err = tx.Commit(ctx)

	return &newChat, nil
}

// AddUserToChat is the resolver for the addUserToChat field.
func (r *mutationResolver) AddUserToChat(ctx context.Context, input model.AddUserToChatInput) (*db.ChatUser, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}
	if input.UserID == currentUser.ID {
		return nil, errors.New("you cannot add yourself to a chat")
	}

	chatUser, err := r.DB.CreateChatUser(ctx, db.CreateChatUserParams{
		ChatID:         input.ChatID,
		UserID:         input.UserID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to add user to chat")
	}

	return &chatUser, nil
}

// RemoveUserFromChat is the resolver for the removeUserFromChat field.
func (r *mutationResolver) RemoveUserFromChat(ctx context.Context, input model.RemoveUserFromChatInput) (*db.ChatUser, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chatUser, err := r.DB.DeleteChatUser(ctx, db.DeleteChatUserParams{
		ChatID:         input.ChatID,
		UserID:         input.UserID,
		OrganisationID: currentUser.OrganisationID,
		CurrentUserID:  currentUser.ID,
	})

	return &chatUser, err
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check that the message is less than 4096 characters
	if len(input.Message) > 4096 {
		return nil, errors.New("message too long, max 4096 characters")
	}

	chatMessage, err := r.DB.CreateChatMessage(ctx, db.CreateChatMessageParams{
		ChatID:         input.ChatID,
		UserID:         currentUser.ID,
		Message:        input.Message,
		OrganisationID: currentUser.OrganisationID,
	})

	// background handling of sending message to other users
	go r.SubscriptionHandler.PublishMessage(&chatMessage)
	go r.ChatMessageProcessor.NewMessage(chatMessage)

	return &chatMessage, nil
}

// EditChatMessage is the resolver for the editChatMessage field.
func (r *mutationResolver) EditChatMessage(ctx context.Context, input model.EditChatMessageInput) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chatMessage, err := r.DB.UpdateChatMessageByUser(ctx, db.UpdateChatMessageByUserParams{
		Message:        input.Message,
		UserID:         currentUser.ID,
		MessageID:      input.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to edit message")
	}

	go r.SubscriptionHandler.PublishMessage(&chatMessage)

	return &chatMessage, nil
}

// UpdateChat is the resolver for the updateChat field.
func (r *mutationResolver) UpdateChat(ctx context.Context, input model.UpdateChatInput) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.UpdateChatName(ctx, db.UpdateChatNameParams{
		Name:           pgtype.Text{String: *input.Name, Valid: true},
		ChatID:         input.ID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to update chat")
	}

	return &chat, nil
}

// MarkMessageAsRead is the resolver for the markMessageAsRead field.
func (r *mutationResolver) MarkMessageAsRead(ctx context.Context, messageID string) (*db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chatMessageView, err := r.DB.MarkChatMessageAsRead(ctx, db.MarkChatMessageAsReadParams{
		ChatMessageID:  messageID,
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to mark message as read")
	}

	chatMessage, err := r.DB.ChatMessageById(ctx, chatMessageView.ChatMessageID)
	if err != nil {
		return nil, errors.New("unable to find chat message")
	}

	return &chatMessage, nil
}

// Chat is the resolver for the chat field.
func (r *queryResolver) Chat(ctx context.Context, id string) (*db.Chat, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	chat, err := r.DB.ChatByIdWithUser(ctx, db.ChatByIdWithUserParams{
		UserID:         currentUser.ID,
		ChatID:         id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to find chat")
	}

	return &chat, nil
}

// Chats is the resolver for the chats field.
func (r *queryResolver) Chats(ctx context.Context, limit *int, offset *int) (*model.ChatConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	chatListWithUserRow, err := r.DB.ChatListWithUser(ctx, db.ChatListWithUserParams{
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
		PageOffset:     int32(pageOffset),
		PageLimit:      int32(pageLimit),
	})

	chats := make([]*db.Chat, len(chatListWithUserRow))

	lo.ForEach(chatListWithUserRow, func(chat db.ChatListWithUserRow, i int) {
		chats = append(chats, &db.Chat{
			ID:             chat.ID,
			Name:           chat.Name,
			OrganisationID: chat.OrganisationID,
			UpdatedAt:      chat.UpdatedAt,
			CreatedAt:      chat.CreatedAt,
			DeletedAt:      chat.DeletedAt,
			Type:           chat.Type,
		})
	})

	// get count from the first row (ChatListWithUserRow.TotalCount)
	count := int(chatListWithUserRow[0].TotalCount)

	pageInfo, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, msg.ErrUnexpected
	}

	return &model.ChatConnection{
		Edges:      chats,
		TotalCount: count,
		PageInfo:   pageInfo,
	}, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context) (<-chan *db.ChatMessage, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	_ = r.SubscriptionHandler.AddUserChannel(currentUser.ID)

	channel := r.SubscriptionHandler.UserChannel[currentUser.ID][len(r.SubscriptionHandler.UserChannel[currentUser.ID])-1]

	go func() {
		<-ctx.Done()
		_ = r.SubscriptionHandler.RemoveChatChannel(currentUser.ID, channel)
	}()

	return channel, nil
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// ChatMessage returns ChatMessageResolver implementation.
func (r *Resolver) ChatMessage() ChatMessageResolver { return &chatMessageResolver{r} }

// ChatUser returns ChatUserResolver implementation.
func (r *Resolver) ChatUser() ChatUserResolver { return &chatUserResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type chatResolver struct{ *Resolver }
type chatMessageResolver struct{ *Resolver }
type chatUserResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
