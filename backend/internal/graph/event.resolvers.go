package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/samber/lo"
)

// Image is the resolver for the image field.
func (r *eventResolver) Image(ctx context.Context, obj *db.Event) (*db.File, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	file, err := r.DB.FileById(ctx, db.FileByIdParams{
		ID:             obj.ImageFileID.String,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &file, nil
}

// Competences is the resolver for the competences field.
func (r *eventResolver) Competences(ctx context.Context, obj *db.Event) ([]*db.Competence, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	competences, err := r.DB.EventCompetenceListByEventId(ctx, db.EventCompetenceListByEventIdParams{
		EventID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return lo.ToSlicePtr(competences), nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *eventResolver) DeletedAt(ctx context.Context, obj *db.Event) (*time.Time, error) {
	if !obj.DeletedAt.Valid {
		return nil, nil
	}

	return &obj.DeletedAt.Time, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	var event db.Event
	event.Title = input.Title

	if input.Body != nil && len(*input.Body) > 0 {
		event.Body = *input.Body
	}

	startsAt, err := time.Parse(time.RFC1123, *input.StartsAt)
	if err != nil {
		return nil, err
	}
	event.StartsAt = startsAt

	endsAt, err := time.Parse(time.RFC1123, *input.EndsAt)
	if err != nil {
		return nil, err
	}
	event.EndsAt = endsAt

	event.OrganisationID = currentUser.OrganisationID

	if event.Recurrence == nil {
		event.Recurrence = []string{}
	}

	event, err = r.DB.CreateEvent(ctx, db.CreateEventParams{
		ImageFileID:    pgtype.Text{},
		OrganisationID: currentUser.OrganisationID,
		Title:          event.Title,
		Body:           event.Body,
		StartsAt:       event.StartsAt,
		EndsAt:         event.EndsAt,
		Recurrence:     event.Recurrence,
	})
	if err != nil {
		return nil, err
	}

	return &event, nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEventInput) (*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	var event db.Event

	query := r.DB.NewQueryBuilder().
		Update("events").
		Where("id = ?", input.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Prefix("RETURNING *")

	if input.Title != nil && len(*input.Title) > 0 {
		event.Title = *input.Title
		query.Set("title = ?", event.Title)
	}

	if input.Body != nil && len(*input.Body) > 0 {
		event.Body = *input.Body
		query.Set("body = ?", event.Body)
	}

	if input.StartsAt != nil {
		startsAt, err := time.Parse(time.RFC1123, *input.StartsAt)
		if err != nil {
			return nil, err
		}
		event.StartsAt = startsAt
		query.Set("starts_at = ?", event.StartsAt)
	}

	if input.EndsAt != nil {
		endsAt, err := time.Parse(time.RFC1123, *input.EndsAt)
		if err != nil {
			return nil, err
		}
		event.EndsAt = endsAt
		query.Set("ends_at = ?", event.EndsAt)
	}

	if event.Recurrence == nil {
		event.Recurrence = []string{}
		//query.Set("recurrence = ?", event.Recurrence)
	}

	err = query.Scan(ctx)

	if err != nil {
		return nil, err
	}

	return &event, nil
}

// ToggleEventCompetence is the resolver for the toggleEventCompetence field.
func (r *mutationResolver) ToggleEventCompetence(ctx context.Context, input model.AddEventCompetenceInput) (*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	_, err = r.DB.CreateEventCompetence(ctx, db.CreateEventCompetenceParams{
		EventID:        input.EventID,
		CompetenceID:   input.CompetenceID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	event, err := r.DB.EventById(ctx, db.EventByIdParams{
		ID:             input.EventID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &event, nil
}

// ArchiveEvent is the resolver for the archiveEvent field.
func (r *mutationResolver) ArchiveEvent(ctx context.Context, id string) (*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	event, err := r.DB.DeleteEvent(ctx, db.DeleteEventParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	return &event, err
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*db.Event, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	event, err := r.DB.EventById(ctx, db.EventByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	return &event, err
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, limit *int, offset *int, filter *model.EventFilterInput, order *model.EventOrderBy, search *string) (*model.EventConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	var events []*db.Event

	query := r.DB.NewQueryBuilder().
		Select("*").
		From("events").
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(uint64(pageLimit)).
		Offset(uint64(pageOffset))

	if search != nil && len(*search) > 0 {
		// TODO: improve search perhaps using meilisearch
		query.Where("title ILIKE ?", "%"+*search+"%")
	} else {
		if order == nil {
			query.OrderBy("created_at")
		}
	}

	// Filters
	if filter != nil {
		if filter.From != nil {
			query.Where("starts_at >= ?", filter.From)
		}
		if filter.To != nil {
			query.Where("ends_at <= ?", filter.To)
		}
	}

	// Order
	if order != nil {
		if *order == model.EventOrderByEndsAtAsc {
			query.OrderBy("ends_at")
		}
		if *order == model.EventOrderByEndsAtDesc {
			query.OrderBy("ends_at DESC")
		}
		if *order == model.EventOrderByStartsAtAsc {
			query.OrderBy("starts_at")
		}
		if *order == model.EventOrderByStartsAtDesc {
			query.OrderBy("starts_at DESC")
		}
	}

	err = query.Scan(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: Yeah well same problem as before
	count := 10_000

	// Page info
	page, err := helper.CreatePageInfo(pageLimit, pageOffset, count)
	if err != nil {
		return nil, err
	}

	return &model.EventConnection{
		Edges:      events,
		PageInfo:   page,
		TotalCount: count,
	}, nil
}

// ExportEvents is the resolver for the exportEvents field.
func (r *queryResolver) ExportEvents(ctx context.Context, input model.ExportEventsInput) ([]*model.ExportEventsPayload, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	orgId := currentUser.OrganisationID

	// TODO: might not work
	from, err := time.Parse(time.RFC3339, input.From)
	to, err := time.Parse(time.RFC3339, input.To)
	deleted := input.Deleted

	// TODO: another day, another fix
	events, err := r.DB.ExportEvents(ctx, db.ExportEventsParams{
		OrganisationID: orgId,
		From:           from,
		To:             to,
		ShowArchived:   deleted,
	})
	if err != nil {
		return nil, err
	}

	//parse events to model.ExportEventsPayload

	var payload []*model.ExportEventsPayload
	for _, event := range events {
		payload = append(payload, &model.ExportEventsPayload{
			ID:       event.ID,
			Title:    event.Title,
			Body:     event.Body,
			StartsAt: event.StartsAt.String(),
			EndsAt:   event.EndsAt.String(),
			Subjects: string(event.Subjects),
		})

	}

	// TODO: properly map the events to the payload
	return []*model.ExportEventsPayload{}, nil
}

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

type eventResolver struct{ *Resolver }
