package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var organisation db.Organisation
	err = r.DB.NewSelect().Model(&organisation).Where("id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	//// check if the email is in the allowed domains
	//if isStringInArray(input.Email, organisation.AllowedDomains) {
	//	return nil, errors.New("email is not in the allowed domains (allowed domains: " + strings.Join(organisation.AllowedDomains, ", ") + ")")
	//}

	var count int
	count, err = r.DB.NewSelect().Model(&db.User{}).Where("organisation_id = ?", currentUser.OrganisationID).Where("email = ?", input.Email).Count(ctx)
	if err != nil {
		return nil, err
	}
	if count > 0 {
		return nil, errors.New("email is already in the database")
	}

	// create a new user
	user := db.User{
		OrganisationID: currentUser.OrganisationID,
		Role:           input.Role,
		Email:          sql.NullString{String: input.Email, Valid: true},
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	}

	// insert the user into the database
	err = r.DB.NewInsert().Model(&user).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Email the user
	token := nanoid.Must(32)
	_, err = r.DB.NewUpdate().Model(&user).Set("recovery_token = ?", token).Set("recovery_sent_at = now()").Where("id = ?", user.ID).Exec(ctx)
	if err != nil {
		return nil, err
	}

	err = r.Mailer.SendInvite(input.Email, user.FirstName, organisation.Name, currentUser.Language, token)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// update the user
	user := db.User{
		ID:             input.ID,
		OrganisationID: currentUser.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
	}

	_, err = r.DB.NewUpdate().
		Model(&user).
		OmitZero().
		WherePK().
		Where("organisation_id = ?", currentUser.OrganisationID).
		Returning("*").
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	// Update the user_student if the role is student
	if user.Role == "student" {
		student := db.UserStudent{
			UserID:         user.ID,
			OrganisationID: currentUser.OrganisationID,
		}

		// Check the optional fields
		if input.Grade != nil {
			student.Grade = int32(*input.Grade)
		}
		if input.Birthday != nil {
			student.Birthday = bun.NullTime{Time: *input.Birthday}
		}
		if input.JoinedAt != nil {
			student.JoinedAt = bun.NullTime{Time: *input.JoinedAt}
		}
		if input.LeftAt != nil {
			student.LeftAt = bun.NullTime{Time: *input.LeftAt}
		}
		if input.Emoji != nil {
			student.Emoji = sql.NullString{String: *input.Emoji, Valid: true}
		}
		if input.MissedHours != nil {
			student.MissedHours = int32(*input.MissedHours)
		}
		if input.MissedHoursExcused != nil {
			student.MissedHoursExcused = int32(*input.MissedHoursExcused)
		}

		_, err = r.DB.NewUpdate().
			Model(&student).
			OmitZero().
			Where("user_id = ?", user.ID).
			Where("organisation_id = ?", currentUser.OrganisationID).
			Returning("*").
			Exec(ctx)
		if err != nil {
			return nil, nil
		}
	}

	return &user, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// check whether the user is already archived
	count, err := r.DB.NewSelect().Model(&db.User{}).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Where("deleted_at IS NOT NULL").Count(ctx)
	if err != nil {
		return nil, err
	}
	if count > 0 {
		return nil, errors.New("user is already archived")
	}

	user := &db.User{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
		DeletedAt: bun.NullTime{
			Time: time.Now(),
		},
	}

	// archive the user by setting the deleted_at field to the current time
	res, err := r.DB.NewUpdate().Model(user).Column("deleted_at").Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return nil, err
	}
	if affected == 0 {
		return nil, errors.New("user not found")
	}

	// If the user is a student, we also need to archive the user_student
	if user.Role == "student" {
		student := db.UserStudent{
			UserID:         user.ID,
			OrganisationID: currentUser.OrganisationID,
			DeletedAt: bun.NullTime{
				Time: time.Now(),
			},
		}

		_, err = r.DB.NewUpdate().Model(&student).Column("deleted_at").Where("user_id = ?", user.ID).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	// Remove the sessions for the user
	_, err = r.DB.NewDelete().Model(&db.Session{}).Where("user_id = ?", user.ID).Exec(ctx)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return nil, err
	}

	return user, nil
}

// UpdateUserLanguage is the resolver for the updateUserLanguage field.
func (r *mutationResolver) UpdateUserLanguage(ctx context.Context, language model.UserLanguage) (*db.User, error) {
	// We get the currentUser from context
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	updatedUser := db.User{
		ID:             currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
		Language:       language,
	}

	// update the user
	_, err = r.DB.NewUpdate().
		Model(&updatedUser).
		Column("language").
		Where("id = ?", currentUser.ID).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &updatedUser, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput, search *string) (*model.UserConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	// query the users
	var users []*db.User
	query := r.DB.NewSelect().
		Model(&users).
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(pageLimit).
		Offset(pageOffset)

	if filter != nil {
		if filter.Role != nil && len(filter.Role) > 0 {
			query.Where("role IN (?)", bun.In(filter.Role))
		}
		if filter.OrderBy != nil {
			switch *filter.OrderBy {
			case model.UserOrderByFirstNameAsc:
				query.OrderExpr("first_name ASC, last_name ASC")
			case model.UserOrderByFirstNameDesc:
				query.OrderExpr("first_name DESC, last_name DESC")
			case model.UserOrderByLastNameAsc:
				query.OrderExpr("last_name ASC, first_name ASC")
			case model.UserOrderByLastNameDesc:
				query.OrderExpr("last_name DESC, first_name DESC")
			default:
				query.OrderExpr("last_name ASC, first_name ASC")
			}
		}
		if filter.ShowDeleted != nil && *filter.ShowDeleted == true {
			query.WhereDeleted()
		}
	}

	if search != nil && *search != "" {
		withoutSpace := strings.Replace(*search, " ", "", -1)
		// TODO: refactor this
		query.Where("first_name ILIKE ? OR last_name ILIKE ? OR first_name || last_name ILIKE ? OR last_name || first_name ILIKE ?", "%"+withoutSpace+"%", "%"+withoutSpace+"%", "%"+withoutSpace+"%", "%"+withoutSpace+"%")
	}

	count, err := query.ScanAndCount(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := helper.CreatePageInfo(pageOffset, pageLimit, count)
	if err != nil {
		return nil, err
	}

	return &model.UserConnection{
		Edges:      users,
		PageInfo:   pageInfo,
		TotalCount: count,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	err = r.DB.NewSelect().Model(&user).Where("id = ?", currentUser.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Email is the resolver for the email field.
func (r *userResolver) Email(ctx context.Context, obj *db.User) (*string, error) {
	if obj.Email.Valid {
		return &obj.Email.String, nil
	}

	return nil, nil
}

// Student is the resolver for the student field.
func (r *userResolver) Student(ctx context.Context, obj *db.User) (*db.UserStudent, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var userStudent db.UserStudent
	err = r.DB.NewSelect().Model(&userStudent).Where("user_id = ?", obj.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// Language is the resolver for the language field.
func (r *userResolver) Language(ctx context.Context, obj *db.User) (*model.UserLanguage, error) {
	panic(fmt.Errorf("not implemented: Language - language"))
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if obj.DeletedAt.IsZero() {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// InviteAccepted is the resolver for the inviteAccepted field.
func (r *userResolver) InviteAccepted(ctx context.Context, obj *db.User) (bool, error) {
	_, err := middleware.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	if obj.Password.Valid {
		return true, nil
	}

	return false, nil
}

// LastSeenAt is the resolver for the lastSeenAt field.
func (r *userResolver) LastSeenAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	randomTime := rand.Int63n(time.Now().Unix()-94608000) + 94608000
	randomNow := time.Unix(randomTime, 0)

	return &randomNow, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
