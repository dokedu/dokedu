package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"math/rand"
	"strings"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/helper"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/jackc/pgx/v5/pgtype"
	gonanoid "github.com/matoous/go-nanoid/v2"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	organisation, err := r.DB.GLOBAL_OrganisationById(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	userParams := db.CreateUserParams{
		Role:           input.Role,
		Email:          pgtype.Text{String: input.Email, Valid: true},
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		OrganisationID: currentUser.OrganisationID,
	}

	user, err := r.DB.CreateUser(ctx, userParams)
	// TODO: check if returns error because user already exists with the email
	if err != nil {
		return nil, err
	}

	// Email the user
	token := gonanoid.Must(32)
	//_, err = r.DB.NewUpdate().Model(&user).Set("recovery_token = ?", token).Set("recovery_sent_at = now()").Where("id = ?", user.ID).Exec(ctx)
	recoveryTokenParams := db.UpdateUserRecoveryTokenParams{
		ID:            user.ID,
		RecoveryToken: pgtype.Text{String: token, Valid: true},
	}
	r.DB.UpdateUserRecoveryToken(ctx, recoveryTokenParams)
	if err != nil {
		return nil, err
	}

	if input.Email != "" {
		err = r.Mailer.SendInvite(input.Email, user.FirstName, organisation.Name, currentUser.Language.UserLang, token)
		if err != nil {
			return nil, err
		}
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	updateUserParams := db.UpdateUserParams{
		ID:             input.ID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		OrganisationID: currentUser.OrganisationID,
	}
	user, err := r.DB.UpdateUser(ctx, updateUserParams)
	if err != nil {
		return nil, err
	}

	// Update the user_student if the role is student
	if user.Role == "student" {
		studentParams := db.UpdateUserStudentParams{
			UserID:         user.ID,
			OrganisationID: currentUser.OrganisationID,
		}

		// Check the optional fields
		if input.Grade != nil {
			studentParams.Grade = int32(*input.Grade)
		}
		if input.Birthday != nil {
			studentParams.Birthday = pgtype.Date{Time: *input.Birthday}
		}
		if input.JoinedAt != nil {
			studentParams.JoinedAt = pgtype.Timestamptz{Time: *input.JoinedAt}
		}
		if input.LeftAt != nil {
			studentParams.LeftAt = pgtype.Timestamptz{Time: *input.LeftAt}
		}
		if input.Emoji != nil {
			studentParams.Emoji = pgtype.Text{String: *input.Emoji, Valid: true}
		}
		if input.MissedHours != nil {
			studentParams.MissedHours = pgtype.Int4{Int32: int32(*input.MissedHours), Valid: true}
		}
		if input.MissedHoursExcused != nil {
			studentParams.MissedHoursExcused = pgtype.Int4{Int32: int32(*input.MissedHoursExcused), Valid: true}
		}

		_, err = r.DB.UpdateUserStudent(ctx, studentParams)
		if err != nil {
			return nil, nil
		}
	}

	return &user, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// Delete the user by setting the deleted_at field to the current time
	user, err := r.DB.DeleteUserById(ctx, db.DeleteUserByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// If the user is a student, we also need to archive the user_student
	if user.Role == db.UserRoleStudent {
		_, err = r.DB.DeleteUserStudent(ctx, db.DeleteUserStudentParams{
			UserID:         user.ID,
			OrganisationID: currentUser.OrganisationID,
		})
		if err != nil {
			return nil, err
		}
	}

	// Remove the sessions for the user
	err = r.DB.GLOBAL_DeleteSessionsByUserID(ctx, user.ID)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return nil, err
	}

	return &user, nil
}

// UpdateUserLanguage is the resolver for the updateUserLanguage field.
func (r *mutationResolver) UpdateUserLanguage(ctx context.Context, language model.UserLanguage) (*db.User, error) {
	// We get the currentUser from context
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	user, err := r.DB.UpdateUserLanguage(ctx, db.UpdateUserLanguageParams{
		ID:             currentUser.ID,
		Language:       db.NullUserLang{UserLang: db.UserLang(language), Valid: true},
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput, search *string) (*model.UserConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	pageLimit, pageOffset := helper.SetPageLimits(limit, offset)

	// query the users
	var users []*db.User
	query := r.DB.NewQueryBuilder().
		Select("*").
		From("users").
		Where("organisation_id = ?", currentUser.OrganisationID).
		Limit(uint64(pageLimit)).
		Offset(uint64(pageOffset))

	if filter != nil {
		if filter.Role != nil && len(filter.Role) > 0 {
			query.Where("role IN (?)", filter.Role)
		}
		if filter.OrderBy != nil {
			switch *filter.OrderBy {
			case model.UserOrderByFirstNameAsc:
				query.OrderBy("first_name ASC, last_name ASC")
			case model.UserOrderByFirstNameDesc:
				query.OrderBy("first_name DESC, last_name DESC")
			case model.UserOrderByLastNameAsc:
				query.OrderBy("last_name ASC, first_name ASC")
			case model.UserOrderByLastNameDesc:
				query.OrderBy("last_name DESC, first_name DESC")
			default:
				query.OrderBy("last_name ASC, first_name ASC")
			}
		}
		if filter.ShowDeleted != nil && *filter.ShowDeleted {
			query.Where("deleted_at IS NOT NULL")
		} else {
			query.Where("deleted_at IS NULL")
		}
	}

	if search != nil && *search != "" {
		withoutSpace := strings.Replace(*search, " ", "", -1)
		// TODO: refactor this
		query.Where("first_name ILIKE ? OR last_name ILIKE ? OR first_name || last_name ILIKE ? OR last_name || first_name ILIKE ?", "%"+withoutSpace+"%", "%"+withoutSpace+"%", "%"+withoutSpace+"%", "%"+withoutSpace+"%")
	}

	err = query.Scan()
	if err != nil {
		return nil, err
	}

	// TODO: properly query all user
	// count := 10_000
	count, err := r.DB.UserListCount(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	pageInfo, err := helper.CreatePageInfo(pageOffset, pageLimit, int(count))
	if err != nil {
		return nil, err
	}

	return &model.UserConnection{
		Edges:      users,
		PageInfo:   pageInfo,
		TotalCount: int(count),
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	var user db.User
	user, err = r.DB.UserById(ctx, db.UserByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	return &currentUser.User, nil
}

// Email is the resolver for the email field.
func (r *userResolver) Email(ctx context.Context, obj *db.User) (*string, error) {
	if obj.Email.Valid {
		return &obj.Email.String, nil
	}

	return nil, nil
}

// Student is the resolver for the student field.
func (r *userResolver) Student(ctx context.Context, obj *db.User) (*db.UserStudent, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	//var userStudent db.UserStudent
	userStudent, err := r.DB.UserStudentByUserId(ctx, db.UserStudentByUserIdParams{
		ID:             obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// Language is the resolver for the language field.
func (r *userResolver) Language(ctx context.Context, obj *db.User) (*model.UserLanguage, error) {
	if obj.Language.Valid {
		switch obj.Language.UserLang {
		case db.UserLangEn:
			lgn := model.UserLanguageEn
			return &lgn, nil
		case db.UserLangDe:
			lgn := model.UserLanguageDe
			return &lgn, nil
		default:
			return nil, errors.New("unknown language")
		}
	}
	return nil, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// InviteAccepted is the resolver for the inviteAccepted field.
func (r *userResolver) InviteAccepted(ctx context.Context, obj *db.User) (bool, error) {
	_, err := middleware.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	if obj.Password.Valid {
		return true, nil
	}

	return false, nil
}

// LastSeenAt is the resolver for the lastSeenAt field.
func (r *userResolver) LastSeenAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	randomTime := rand.Int63n(time.Now().Unix()-94608000) + 94608000
	randomNow := time.Unix(randomTime, 0)

	return &randomNow, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
