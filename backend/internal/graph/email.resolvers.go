package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/dokedu/dokedu/backend/internal/dataloaders"
	"github.com/dokedu/dokedu/backend/internal/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/middleware"
)

// CreatedAt is the resolver for the createdAt field.
func (r *domainResolver) CreatedAt(ctx context.Context, obj *db.Domain) (string, error) {
	if obj.CreatedAt.IsZero() {
		return "", nil
	}

	return obj.CreatedAt.Format(time.RFC1123Z), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *emailResolver) CreatedAt(ctx context.Context, obj *db.Email) (string, error) {
	if obj.CreatedAt.IsZero() {
		return "", nil
	}

	return obj.CreatedAt.Format(time.RFC1123Z), nil
}

// User is the resolver for the user field.
func (r *emailAccountResolver) User(ctx context.Context, obj *db.EmailAccount) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	return dataloaders.GetUser(ctx, obj.UserID.String, currentUser)
}

// CreatedAt is the resolver for the createdAt field.
func (r *emailAccountResolver) CreatedAt(ctx context.Context, obj *db.EmailAccount) (string, error) {
	if obj.CreatedAt.IsZero() {
		return "", nil
	}

	return obj.CreatedAt.Format(time.RFC1123Z), nil
}

// Members is the resolver for the members field.
func (r *emailAccountResolver) Members(ctx context.Context, obj *db.EmailAccount) ([]*db.EmailGroupMember, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	// If the EmailAccount is not a group, return nil
	if obj.Type != db.EmailAccountTypeGroup {
		return nil, nil
	}

	// Fetch the members
	var members []*db.EmailGroupMember
	err = r.DB.NewSelect().Model(&members).Where("member_of = ?", obj.Name).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return members, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *emailForwardingResolver) CreatedAt(ctx context.Context, obj *db.EmailForwarding) (string, error) {
	if obj.CreatedAt.IsZero() {
		return "", nil
	}

	return obj.CreatedAt.Format(time.RFC1123Z), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *emailGroupMemberResolver) CreatedAt(ctx context.Context, obj *db.EmailGroupMember) (string, error) {
	if obj.CreatedAt.IsZero() {
		return "", nil
	}

	return obj.CreatedAt.Format(time.RFC1123Z), nil
}

// CreateEmailAccount is the resolver for the createEmailAccount field.
func (r *mutationResolver) CreateEmailAccount(ctx context.Context, input model.CreateEmailAccountInput) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	emailAccount := db.EmailAccount{
		Name:           input.Name,
		Secret:         "TODO",
		Type:           input.Type,
		Quota:          0,
		Active:         true,
		UserID:         sql.NullString{String: currentUser.ID, Valid: true},
		OrganisationID: currentUser.OrganisationID,
	}

	if input.Description != nil {
		emailAccount.Description = *input.Description
	}

	err = r.DB.NewInsert().Model(&emailAccount).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailAccount, nil
}

// UpdateEmailAccount is the resolver for the updateEmailAccount field.
func (r *mutationResolver) UpdateEmailAccount(ctx context.Context, input model.UpdateEmailAccountInput) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailAccount db.EmailAccount
	err = r.DB.NewSelect().Model(&emailAccount).Where("name = ?", input.Name).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	if input.Name != nil {
		emailAccount.Name = *input.Name
	}
	if input.Description != nil {
		emailAccount.Description = *input.Description
	}
	if input.Type != nil {
		emailAccount.Type = *input.Type
	}
	if input.Quota != nil {
		emailAccount.Quota = *input.Quota
	}
	if input.Active != nil {
		emailAccount.Active = *input.Active
	}
	err = r.DB.NewUpdate().Model(&emailAccount).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailAccount, nil
}

// DeleteEmailAccount is the resolver for the deleteEmailAccount field.
func (r *mutationResolver) DeleteEmailAccount(ctx context.Context, input model.DeleteEmailAccountInput) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailAccount db.EmailAccount
	err = r.DB.NewSelect().Model(&emailAccount).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: Check if email account is in use
	emailAccount.Active = false

	err = r.DB.NewUpdate().Model(&emailAccount).Returning("*").Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailAccount, nil
}

// CreateEmailGroupMember is the resolver for the createEmailGroupMember field.
func (r *mutationResolver) CreateEmailGroupMember(ctx context.Context, input model.CreateEmailGroupMemberInput) (*db.EmailGroupMember, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	emailGroupMember := db.EmailGroupMember{
		Name:           input.Name,
		MemberOf:       input.MemberOf,
		OrganisationID: currentUser.OrganisationID,
	}

	err = r.DB.NewInsert().Model(&emailGroupMember).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailGroupMember, nil
}

// DeleteEmailGroupMember is the resolver for the deleteEmailGroupMember field.
func (r *mutationResolver) DeleteEmailGroupMember(ctx context.Context, input model.DeleteEmailGroupMemberInput) (*db.EmailGroupMember, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailGroupMember db.EmailGroupMember
	err = r.DB.NewSelect().Model(&emailGroupMember).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// TODO instead of hard delete use soft delete
	err = r.DB.NewDelete().Model(&emailGroupMember).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailGroupMember, nil
}

// CreateEmail is the resolver for the createEmail field.
func (r *mutationResolver) CreateEmail(ctx context.Context, input model.CreateEmailInput) (*db.Email, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	email := db.Email{
		Name:           input.Name,
		Address:        input.Address,
		Type:           input.Type,
		OrganisationID: currentUser.OrganisationID,
	}
	err = r.DB.NewInsert().Model(&email).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &email, nil
}

// DeleteEmail is the resolver for the deleteEmail field.
func (r *mutationResolver) DeleteEmail(ctx context.Context, input model.DeleteEmailInput) (*db.Email, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var email db.Email
	err = r.DB.NewSelect().Model(&email).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// TODO instead of hard delete use soft delete
	err = r.DB.NewDelete().Model(&email).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &email, nil
}

// CreateEmailForwarding is the resolver for the createEmailForwarding field.
func (r *mutationResolver) CreateEmailForwarding(ctx context.Context, input model.CreateEmailForwardingInput) (*db.EmailForwarding, error) {
	panic(fmt.Errorf("not implemented: CreateEmailForwarding - createEmailForwarding"))
}

// DeleteEmailForwarding is the resolver for the deleteEmailForwarding field.
func (r *mutationResolver) DeleteEmailForwarding(ctx context.Context, input model.DeleteEmailForwardingInput) (*db.EmailForwarding, error) {
	panic(fmt.Errorf("not implemented: DeleteEmailForwarding - deleteEmailForwarding"))
}

// CreateDomain is the resolver for the createDomain field.
func (r *mutationResolver) CreateDomain(ctx context.Context, input model.CreateDomainInput) (*db.Domain, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	return nil, errors.New("you are not allowed to create a domain")
	//domain := db.Domain{
	//	Name:           input.Name,
	//	OrganisationID: currentUser.OrganisationID,
	//}
	//err = r.DB.NewInsert().Model(&domain).Scan(ctx)
	//if err != nil {
	//	return nil, err
	//}
	//
	//return &domain, nil
}

// DeleteDomain is the resolver for the deleteDomain field.
func (r *mutationResolver) DeleteDomain(ctx context.Context, input model.DeleteDomainInput) (*db.Domain, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	return nil, errors.New("you are not allowed to create a domain")

	//var domain db.Domain
	//err = r.DB.NewSelect().Model(&domain).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	//if err != nil {
	//	return nil, err
	//}
	//
	//// TODO instead of hard delete use soft delete
	//err = r.DB.NewDelete().Model(&domain).Scan(ctx)
	//if err != nil {
	//	return nil, err
	//}
	//
	//return &domain, nil
}

// CreateEmailGroup is the resolver for the createEmailGroup field.
func (r *mutationResolver) CreateEmailGroup(ctx context.Context, input model.CreateEmailGroupInput) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, errors.New("no user found in the context")
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	// Insert new email account of type group
	account := db.EmailAccount{
		Name:           input.Name,
		Type:           db.EmailAccountTypeGroup,
		Description:    *input.Description,
		OrganisationID: currentUser.OrganisationID,
	}

	// Check if domain exists and belongs to the organisation
	domainName := input.Name[strings.Index(input.Name, "@")+1:]
	domain := db.Domain{
		Name: domainName,
	}
	err = r.DB.NewSelect().Model(&domain).Where("name = ?", domainName).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errors.New("domain does not exist")
		} else {
			return nil, err
		}
	}

	_, err = r.DB.NewInsert().Model(&account).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}

	// For each user in the group, create a new email group member
	for _, user := range input.Members {
		groupMember := db.EmailGroupMember{
			Name:           *user,
			OrganisationID: currentUser.OrganisationID,
			MemberOf:       input.Name,
		}
		err = r.DB.NewInsert().Model(&groupMember).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
		if err != nil {
			return nil, err
		}
	}

	return &account, nil
}

// UpdateEmailGroup is the resolver for the updateEmailGroup field.
func (r *mutationResolver) UpdateEmailGroup(ctx context.Context, input model.UpdateEmailGroupInput) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, errors.New("no user found in the context")
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}
	// Fetch the current group
	var group db.EmailAccount
	err = r.DB.NewSelect().Model(&group).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Update email account of type group
	account := db.EmailAccount{
		ID:             input.ID,
		Name:           *input.Name,
		Type:           db.EmailAccountTypeGroup,
		Description:    *input.Description,
		OrganisationID: currentUser.OrganisationID,
		CreatedAt:      group.CreatedAt,
	}

	// Check if domain exists and belongs to the organisation
	domainName := (*input.Name)[strings.Index(*input.Name, "@")+1:]
	domain := db.Domain{
		Name: domainName,
	}
	err = r.DB.NewSelect().Model(&domain).Where("name = ?", domainName).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errors.New("domain does not exist")
		} else {
			return nil, err
		}
	}

	// Check if the group name has changed
	if account.Name != group.Name {
		// Update group members with new group name
		var groupMembers []db.EmailGroupMember
		err = r.DB.NewSelect().Model(&groupMembers).Where("member_of = ?", group.Name).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
		if err != nil {
			return nil, err
		}

		// Update each entry
		for _, member := range groupMembers {
			member.MemberOf = account.Name
			_, err = r.DB.NewUpdate().Model(&member).Where("name = ?", member.Name).Where("member_of = ?", group.Name).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
			if err != nil {
				return nil, err
			}
		}
	}

	// Update the group
	_, err = r.DB.NewUpdate().Model(&account).Where("id = ?", input.ID).Where("organisation_id = ?", currentUser.OrganisationID).Returning("*").Exec(ctx)
	if err != nil {
		return nil, err
	}

	// Get the current group members
	var groupMembers []db.EmailGroupMember
	err = r.DB.NewSelect().Model(&groupMembers).Where("member_of = ?", account.Name).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Remove the ones not in input.Users
	for _, member := range groupMembers {
		found := false
		for _, user := range input.Members {
			if *user == member.Name {
				found = true
			}
		}

		if !found {
			// Delete the group member
			_, err = r.DB.NewDelete().Model(&member).Where("id = ?", member.ID).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
			if err != nil {
				return nil, err
			}
		}
	}

	// Add all users that are currently not in group
	for _, user := range input.Members {
		found := false
		for _, member := range groupMembers {
			if *user == member.Name {
				found = true
			}
		}

		if !found {
			// Create the group member
			groupMember := db.EmailGroupMember{
				Name:           *user,
				OrganisationID: currentUser.OrganisationID,
				MemberOf:       account.Name,
			}
			err = r.DB.NewInsert().Model(&groupMember).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
			if err != nil {
				return nil, err
			}
		}
	}

	return &account, nil
}

// DeleteEmailGroup is the resolver for the deleteEmailGroup field.
func (r *mutationResolver) DeleteEmailGroup(ctx context.Context, id string) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, errors.New("no user found in the context")
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	// Fetch the current group
	var group db.EmailAccount
	err = r.DB.NewSelect().Model(&group).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Delete the group
	_, err = r.DB.NewDelete().Model(&group).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
	if err != nil {
		return nil, err
	}

	// Delete the group members
	var groupMembers []db.EmailGroupMember
	_, err = r.DB.NewDelete().Model(&groupMembers).Where("member_of = ?", group.Name).Where("organisation_id = ?", currentUser.OrganisationID).Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &group, nil
}

// EmailAccounts is the resolver for the emailAccounts field.
func (r *queryResolver) EmailAccounts(ctx context.Context, filter *model.EmailAccountFilter) (*model.EmailAccountConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailAccounts []*db.EmailAccount
	query := r.DB.NewSelect().Model(&emailAccounts).Where("organisation_id = ?", currentUser.OrganisationID)

	if filter != nil {
		if filter.Type != nil {
			if *filter.Type == "GROUP" {
				query.Where("type = ?", db.EmailAccountTypeGroup)
			}
			if *filter.Type == "INDIVIDUAL" {
				query.Where("type = ?", db.EmailAccountTypeIndividual)
			}
		}
	}

	err = query.Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &model.EmailAccountConnection{
		Edges: emailAccounts,
		PageInfo: &model.PageInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
		},
	}, nil
}

// EmailAccount is the resolver for the emailAccount field.
func (r *queryResolver) EmailAccount(ctx context.Context, id string) (*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailAccount db.EmailAccount
	err = r.DB.NewSelect().Model(&emailAccount).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailAccount, nil
}

// EmailGroupMembers is the resolver for the EmailGroupMembers field.
func (r *queryResolver) EmailGroupMembers(ctx context.Context) (*model.EmailGroupMemberConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailGroupMembers []*db.EmailGroupMember
	err = r.DB.NewSelect().Model(&emailGroupMembers).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &model.EmailGroupMemberConnection{
		Edges: emailGroupMembers,
		PageInfo: &model.PageInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
		},
	}, nil
}

// EmailGroupMember is the resolver for the EmailGroupMember field.
func (r *queryResolver) EmailGroupMember(ctx context.Context, id string) (*db.EmailGroupMember, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailGroups *db.EmailGroupMember
	err = r.DB.NewSelect().Model(&emailGroups).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return emailGroups, nil
}

// Emails is the resolver for the emails field.
func (r *queryResolver) Emails(ctx context.Context) (*model.EmailConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emails []*db.Email
	err = r.DB.NewSelect().Model(&emails).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &model.EmailConnection{
		Edges: emails,
		PageInfo: &model.PageInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
		},
	}, nil
}

// Email is the resolver for the email field.
func (r *queryResolver) Email(ctx context.Context, id string) (*db.Email, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var email db.Email
	err = r.DB.NewSelect().Model(&email).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &email, nil
}

// EmailForwardings is the resolver for the emailForwardings field.
func (r *queryResolver) EmailForwardings(ctx context.Context) (*model.EmailForwardingConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailForwardings []*db.EmailForwarding
	err = r.DB.NewSelect().Model(&emailForwardings).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &model.EmailForwardingConnection{
		Edges: emailForwardings,
		PageInfo: &model.PageInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
		},
	}, nil
}

// EmailForwarding is the resolver for the emailForwarding field.
func (r *queryResolver) EmailForwarding(ctx context.Context, id string) (*db.EmailForwarding, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailForwarding db.EmailForwarding
	err = r.DB.NewSelect().Model(&emailForwarding).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &emailForwarding, nil
}

// Domains is the resolver for the domains field.
func (r *queryResolver) Domains(ctx context.Context) (*model.DomainConnection, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var domains []*db.Domain
	err = r.DB.NewSelect().Model(&domains).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &model.DomainConnection{
		Edges: domains,
		PageInfo: &model.PageInfo{
			HasNextPage:     false,
			HasPreviousPage: false,
		},
	}, nil
}

// Domain is the resolver for the domain field.
func (r *queryResolver) Domain(ctx context.Context, id string) (*db.Domain, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var domain db.Domain
	err = r.DB.NewSelect().Model(&domain).Where("id = ?", id).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &domain, nil
}

// EmailAccounts is the resolver for the emailAccounts field.
func (r *userResolver) EmailAccounts(ctx context.Context, obj *db.User) ([]*db.EmailAccount, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}
	if !currentUser.HasPermissionAdmin() {
		return nil, errors.New("no permission")
	}

	var emailAccounts []*db.EmailAccount
	err = r.DB.NewSelect().Model(&emailAccounts).Where("user_id = ?", obj.ID).Where("organisation_id = ?", currentUser.OrganisationID).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return emailAccounts, nil
}

// Domain returns DomainResolver implementation.
func (r *Resolver) Domain() DomainResolver { return &domainResolver{r} }

// Email returns EmailResolver implementation.
func (r *Resolver) Email() EmailResolver { return &emailResolver{r} }

// EmailAccount returns EmailAccountResolver implementation.
func (r *Resolver) EmailAccount() EmailAccountResolver { return &emailAccountResolver{r} }

// EmailForwarding returns EmailForwardingResolver implementation.
func (r *Resolver) EmailForwarding() EmailForwardingResolver { return &emailForwardingResolver{r} }

// EmailGroupMember returns EmailGroupMemberResolver implementation.
func (r *Resolver) EmailGroupMember() EmailGroupMemberResolver { return &emailGroupMemberResolver{r} }

type domainResolver struct{ *Resolver }
type emailResolver struct{ *Resolver }
type emailAccountResolver struct{ *Resolver }
type emailForwardingResolver struct{ *Resolver }
type emailGroupMemberResolver struct{ *Resolver }
