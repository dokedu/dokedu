package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"slices"
	"time"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/jackc/pgx/v5/pgtype"
	excelize "github.com/xuri/excelize/v2"
)

// ImportStudents imports students from an Excel file.
func (r *mutationResolver) ImportStudents(ctx context.Context, input model.ImportStudentsInput) (*model.ImportStudentsPayload, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, err
	}

	if !currentUser.HasPermissionAdmin() {
		return &model.ImportStudentsPayload{
			Errors: []model.ImportStudentsError{
				model.ImportStudentsErrorPermissionDenied,
			},
		}, nil
	}

	// Validate file content type
	allowedContentTypes := []string{"application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}
	if !slices.Contains(allowedContentTypes, input.File.ContentType) {
		return &model.ImportStudentsPayload{
			Errors: []model.ImportStudentsError{
				model.ImportStudentsErrorFormatWrong,
			},
		}, nil
	}

	// Open Excel file
	file := input.File.File
	f, err := excelize.OpenReader(file)
	if err != nil {
		return nil, err
	}

	// Get first sheet
	sheetMap := f.GetSheetMap()
	var firstSheet string
	for _, sheet := range sheetMap {
		firstSheet = sheet
		break
	}

	// Get rows from first sheet
	rows, err := f.GetRows(firstSheet)
	if err != nil {
		return nil, err
	}

	// Validate headers
	allowedHeaders := []string{"Vorname", "Nachname", "Geburtsdatum"}
	headers := rows[0]
	for _, header := range headers {
		if !slices.Contains(allowedHeaders, header) {
			return &model.ImportStudentsPayload{
				Errors: []model.ImportStudentsError{
					model.ImportStudentsErrorHeaderWrong,
				},
			}, nil
		}
	}

	// Get existing users and students
	existingUsers, err := r.DB.UserList(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	existingStudents, err := r.DB.UserStudentListAll(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	// Create a map of existing students by user ID
	existingStudentsByUserMap := make(map[string]*db.UserStudent)
	for _, student := range existingStudents {
		existingStudentsByUserMap[student.UserID] = &student
	}

	// Create new users and students
	var users []*db.User
	var students []*db.UserStudent

	tx, err := r.DB.DB.Begin(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback(ctx)

	qtx := r.DB.WithTx(tx)

	existingUserCount := 0

LoopRows:
	for _, row := range rows[1:] {
		if len(row) == 0 {
			continue
		}

		user := r.createUserFromRow(row, currentUser.OrganisationID)
		student, err := r.createStudentFromRow(user, row, currentUser.OrganisationID)
		if err != nil {
			return nil, err
		}

		// Check if user already exists
		for _, existingUser := range existingUsers {
			if existingUser.FirstName == user.FirstName && existingUser.LastName == user.LastName {
				existingUserCount++
				continue LoopRows
			}
		}

		// Also check if in the already added users and students there is a user with the same name or birthday
		for _, existingUser := range users {
			if existingUser.FirstName == user.FirstName && existingUser.LastName == user.LastName {
				existingUserCount++
				continue LoopRows
			}
		}

		createdUser, err := qtx.CreateUser(ctx, db.CreateUserParams{
			Role:           db.UserRoleStudent,
			OrganisationID: currentUser.OrganisationID,
			FirstName:      user.FirstName,
			LastName:       user.LastName,
			Email:          user.Email,
			Password:       user.Password,
			Language:       user.Language,
			Sex:            user.Sex,
		})
		if err != nil {
			return nil, err
		}

		student.UserID = createdUser.ID

		createdStudent, err := qtx.CreateUserStudent(ctx, db.CreateUserStudentParams{
			UserID:         createdUser.ID,
			OrganisationID: currentUser.OrganisationID,
			LeftAt:         student.LeftAt,
			Grade:          student.Grade,
			Birthday:       student.Birthday,
			JoinedAt:       student.JoinedAt,
			Emoji:          student.Emoji,
		})
		if err != nil {
			return nil, err
		}

		users = append(users, &createdUser)
		students = append(students, &createdStudent)
	}

	if len(users) > 0 {
		err = tx.Commit(ctx)
		if err != nil {
			return nil, err
		}
	}

	return &model.ImportStudentsPayload{
		UsersCreated: len(users),
		UsersExisted: existingUserCount,
	}, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) createUserFromRow(row []string, organisationID string) *db.User {
	var user db.User
	user.FirstName = row[0]
	user.LastName = row[1]
	user.OrganisationID = organisationID
	user.Role = db.UserRoleStudent

	return &user
}
func (r *mutationResolver) createStudentFromRow(user *db.User, row []string, organisationID string) (*db.UserStudent, error) {
	var student db.UserStudent
	student.UserID = user.ID

	// Parse row[2] as date (currently in format dd.mm.yyyy)
	birthday, err := time.Parse("02.01.2006", row[2])
	if err != nil {
		return nil, err
	}

	student.Birthday = pgtype.Date{Time: birthday, Valid: true}
	student.Grade = 1
	student.OrganisationID = organisationID

	return &student, nil
}
