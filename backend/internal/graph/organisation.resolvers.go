package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"

	"github.com/dokedu/dokedu/backend/internal/database/db"
	"github.com/dokedu/dokedu/backend/internal/graph/model"
	"github.com/dokedu/dokedu/backend/internal/middleware"
	"github.com/dokedu/dokedu/backend/internal/msg"
)

// UpdateOrganisation is the resolver for the updateOrganisation field.
func (r *mutationResolver) UpdateOrganisation(ctx context.Context, input model.UpdateOrganisationInput) (*db.Organisation, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, msg.ErrUnauthenticated
	}
	if !currentUser.HasPermissionAdmin() || currentUser.OrganisationID != input.ID {
		return nil, msg.ErrUnauthorized
	}

	organisation, err := r.DB.GLOBAL_OrganisationById(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	query := r.DB.NewQueryBuilder().Update("organisations").Where("id = ?", input.ID)

	if input.Name != nil {
		query.Set("name", *input.Name)
	}

	if input.LegalName != nil {
		query.Set("legal_name", *input.LegalName)
	}

	if input.Phone != nil {
		query.Set("phone", *input.Phone)
	}

	if input.Website != nil {
		query.Set("website", *input.Website)
	}

	err = query.Scan(ctx, organisation)
	if err != nil {
		return nil, err
	}

	return &organisation, nil
}

// Owner is the resolver for the owner field.
func (r *organisationResolver) Owner(ctx context.Context, obj *db.Organisation) (*db.User, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	user, err := r.DB.UserById(ctx, db.UserByIdParams{
		ID:             obj.OwnerID,
		OrganisationID: currentUser.OrganisationID,
	})
	return &user, err
}

// Applications is the resolver for the applications field.
func (r *organisationResolver) Applications(ctx context.Context, obj *db.Organisation) ([]model.OrganisationApplication, error) {
	var applications []model.OrganisationApplication

	// TODO: is there a better way for this in Go?
	for _, application := range obj.EnabledApps {
		switch application {
		case model.OrganisationApplicationEmail.String():
			applications = append(applications, model.OrganisationApplicationEmail)
			break
		case model.OrganisationApplicationDrive.String():
			applications = append(applications, model.OrganisationApplicationDrive)
			break
		case model.OrganisationApplicationRecord.String():
			applications = append(applications, model.OrganisationApplicationRecord)
			break
		case model.OrganisationApplicationAdmin.String():
			applications = append(applications, model.OrganisationApplicationAdmin)
			break
		case model.OrganisationApplicationSchool.String():
			applications = append(applications, model.OrganisationApplicationSchool)
			break
		case model.OrganisationApplicationChat.String():
			applications = append(applications, model.OrganisationApplicationChat)
			break
		}
	}

	return applications, nil
}

// Organisation is the resolver for the organisation field.
func (r *queryResolver) Organisation(ctx context.Context) (*db.Organisation, error) {
	currentUser, err := middleware.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	organisation, err := r.DB.GLOBAL_OrganisationById(ctx, currentUser.OrganisationID)
	return &organisation, err
}

// Organisation returns OrganisationResolver implementation.
func (r *Resolver) Organisation() OrganisationResolver { return &organisationResolver{r} }

type organisationResolver struct{ *Resolver }
