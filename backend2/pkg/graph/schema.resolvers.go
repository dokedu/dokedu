package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	gonanoid "github.com/matoous/go-nanoid/v2"
	"github.com/samber/lo"
	"golang.org/x/crypto/bcrypt"

	"github.com/dokedu/dokedu/backend/pkg/graph/generated"
	"github.com/dokedu/dokedu/backend/pkg/graph/model"
	"github.com/dokedu/dokedu/backend/pkg/helper"
	"github.com/dokedu/dokedu/backend/pkg/middleware"
	"github.com/dokedu/dokedu/backend/pkg/msg"
	"github.com/dokedu/dokedu/backend/pkg/services/database"
	"github.com/dokedu/dokedu/backend/pkg/services/database/db"
)

// Color is the resolver for the color field.
func (r *competenceResolver) Color(ctx context.Context, obj *db.Competence) (string, error) {
	if !obj.Color.Valid {
		return "blue", nil
	}

	return obj.Color.String, nil
}

// Parents is the resolver for the parents field.
func (r *competenceResolver) Parents(ctx context.Context, obj *db.Competence) ([]db.Competence, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}
	parents, err := r.DB.Loader(ctx).CompetenceParents(currentUser.User).Load(ctx, obj.ID)()
	if err != nil {
		return nil, err
	}

	return parents, nil
}

// SortOrder is the resolver for the sortOrder field.
func (r *competenceResolver) SortOrder(ctx context.Context, obj *db.Competence) (int, error) {
	if !obj.SortOrder.Valid {
		return 0, nil
	}

	return int(obj.SortOrder.Int32), nil
}

// Competences is the resolver for the competences field.
func (r *competenceResolver) Competences(ctx context.Context, obj *db.Competence, search *string, sort *model.CompetenceSort) ([]*db.Competence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	query := r.DB.
		NewQueryBuilder().
		Select("*").
		From("competences").
		Where("competence_id = ?", obj.ID).
		Where("organisation_id = ?", user.OrganisationID)

	if sort != nil {
		switch sort.Field {
		case model.CompetenceSortFieldSortOrder:
			query = query.OrderBy("sort_order ASC")
			query = query.OrderBy("name ASC")
		case model.CompetenceSortFieldName:
			query = query.OrderBy("name ASC")
		case model.CompetenceSortFieldCreatedAt:
			query = query.OrderBy("created_at ASC")
		}
	}

	if search != nil && *search != "" {
		query = query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", *search))
	}

	competences, err := database.ScanSelectMany[db.Competence](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	return lo.ToSlicePtr(competences), nil
}

// UserCompetences is the resolver for the userCompetences field.
func (r *competenceResolver) UserCompetences(ctx context.Context, obj *db.Competence, userID *string) ([]*db.UserCompetence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	if userID == nil {
		return []*db.UserCompetence{}, nil
	}

	userCompetences, err := r.DB.UserCompetenceFindByUserIdAndCompetenceID(ctx, db.UserCompetenceFindByUserIdAndCompetenceIDParams{
		UserID:         *userID,
		CompetenceID:   obj.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return lo.ToSlicePtr(userCompetences), nil
}

// Tendency is the resolver for the tendency field.
func (r *competenceResolver) Tendency(ctx context.Context, obj *db.Competence, userID string) (*model.CompetenceTendency, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	if obj.CompetenceType == db.CompetenceTypeCompetence {
		return nil, nil
	}

	childrenCount, err := r.DB.CompetenceChildrenCount(ctx, db.CompetenceChildrenCountParams{
		CompetenceID:   pgtype.Text{String: obj.ID, Valid: true},
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	userCompetenceCount, err := r.DB.UserCompetenceCount(ctx, db.UserCompetenceCountParams{
		OrganisationID: user.OrganisationID,
		UserID:         userID,
		CompetenceID:   obj.ID,
	})
	if err != nil {
		return nil, err
	}

	var tendency model.CompetenceTendency
	tendency.CountLearnedCompetences = int(userCompetenceCount)
	tendency.CountChildCompetences = int(childrenCount)

	tendency.Tendency = float64(tendency.CountLearnedCompetences) / float64(tendency.CountChildCompetences)

	return &tendency, nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInPayload, error) {
	user, err := r.DB.GLOBAL_UserFindByEmail(ctx, input.Email)
	if err != nil {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	// user.Password is a sql.NullString, so we need to check if it is valid
	if !user.Password.Valid {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password.String), []byte(input.Password)); err != nil {
		return nil, msg.ErrInvalidEmailOrPassword
	}

	// Generate a new token
	token := gonanoid.Must(32)
	_, err = r.DB.GLOBAL_SessionCreate(ctx, db.GLOBAL_SessionCreateParams{
		UserID: user.ID,
		Token:  token,
	})
	if err != nil {
		return nil, errors.New("unable to generate a token")
	}

	// todo: return more data
	return &model.SignInPayload{
		Token: token,
		User:  user,
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (*model.ResetPasswordPayload, error) {
	_, ok := middleware.GetUser(ctx)
	if ok {
		return nil, msg.ErrInvalidInput
	}

	// if there is no user, try to find by recover token
	if input.Token == nil {
		return nil, msg.ErrInvalidInput
	}

	var err error
	user, err := r.DB.GLOBAL_UserFindByRecoveryToken(ctx, *input.Token)
	if err != nil {
		return nil, msg.ErrInvalidRecoveryToken
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	_, err = r.DB.UserUpdatePassword(ctx, db.UserUpdatePasswordParams{
		Password:       string(hashedPassword),
		ID:             user.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, errors.New("unable to update the password")
	}

	// todo: resetting your password should probably invalidate other sessions

	return &model.ResetPasswordPayload{
		Success: true,
	}, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (*model.ForgotPasswordPayload, error) {
	user, err := r.DB.GLOBAL_UserFindByEmail(ctx, input.Email)
	if err != nil {
		return nil, msg.ErrInvalidInput
	}

	// Generate a new token
	token := gonanoid.Must(32)

	// Update the user with the new token
	_, err = r.DB.UserUpdateRecoveryToken(ctx, db.UserUpdateRecoveryTokenParams{
		RecoveryToken:  token,
		ID:             user.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// Send the email to the user
	err = r.Services.Mail.SendPasswordReset(input.Email, user.FirstName, user.LanguageOrDefault(), token)
	if err != nil {
		return nil, err
	}

	return &model.ForgotPasswordPayload{Success: true}, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (bool, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return false, msg.ErrUnauthorized
	}

	err := r.DB.GLOBAL_SessionsDeleteByUserID(ctx, user.User.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// AcceptInvite is the resolver for the acceptInvite field.
func (r *mutationResolver) AcceptInvite(ctx context.Context, token string, input model.SignUpInput) (*model.SignInPayload, error) {
	panic(fmt.Errorf("not implemented: AcceptInvite - acceptInvite"))
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionAdmin() {
		return nil, msg.ErrUnauthorized
	}

	createdUser, err := r.DB.UserCreate(ctx, db.UserCreateParams{
		Role:           input.Role,
		OrganisationID: user.OrganisationID,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		Email:          pgtype.Text{Valid: true, String: input.Email},
	})
	if err != nil {
		return nil, err
	}

	token := gonanoid.Must(32)
	_, err = r.DB.UserUpdateRecoveryToken(ctx, db.UserUpdateRecoveryTokenParams{
		RecoveryToken:  token,
		ID:             createdUser.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	err = r.Services.Mail.SendInvite(input.Email, createdUser.FirstName, user.FirstName, user.LanguageOrDefault(), token)
	if err != nil {
		return nil, err
	}

	return &createdUser, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionAdmin() {
		return nil, msg.ErrUnauthorized
	}

	// update the common user fields
	updatedUser, err := r.DB.UserUpdate(ctx, db.UserUpdateParams{
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		ID:             input.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// if the updated user is a student, update the student fields as well
	if updatedUser.Role == db.UserRoleStudent {
		query := r.DB.NewQueryBuilder().
			Update("user_students").
			Where("user_id = ? and organisation_id = ?", updatedUser.ID, user.OrganisationID)

		var shouldUpdate bool
		if input.Grade != nil {
			shouldUpdate = true
			query = query.Set("grade", *input.Grade)
		}
		if input.Birthday != nil {
			shouldUpdate = true
			query = query.Set("birthday", *input.Birthday)
		}
		if input.LeftAt != nil {
			shouldUpdate = true
			query = query.Set("left_at", *input.LeftAt)
		}
		if input.JoinedAt != nil {
			shouldUpdate = true
			query = query.Set("joined_at", *input.JoinedAt)
		}
		if input.Emoji != nil {
			shouldUpdate = true
			query = query.Set("emoji", *input.Emoji)
		}
		if input.MissedHours != nil {
			shouldUpdate = true
			query = query.Set("missed_hours", *input.MissedHours)
		}
		if input.MissedHoursExcused != nil {
			shouldUpdate = true
			query = query.Set("missed_hours_excused", *input.MissedHoursExcused)
		}

		if shouldUpdate {
			err = database.ExecUpdate(r.DB, ctx, query)
			if err != nil {
				return nil, err
			}
		}
	}

	return &updatedUser, nil
}

// ArchiveUser is the resolver for the archiveUser field.
func (r *mutationResolver) ArchiveUser(ctx context.Context, id string) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionAdmin() {
		return nil, msg.ErrUnauthorized
	}

	// try to find the user
	userToBeArchived, err := r.DB.UserFindByID(ctx, db.UserFindByIDParams{
		ID:             id,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// archive the user
	_, err = r.DB.UserSoftDelete(ctx, db.UserSoftDeleteParams{
		ID:             id,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// if the user is a student, we need to delete the student relation as well
	if userToBeArchived.Role == db.UserRoleStudent {
		_, err = r.DB.UserStudentSoftDeleteByUserID(ctx, db.UserStudentSoftDeleteByUserIDParams{
			UserID:         id,
			OrganisationID: user.OrganisationID,
		})
		if err != nil {
			return nil, err
		}
	}

	// delete all sessions for the user
	err = r.DB.GLOBAL_SessionsDeleteByUserID(ctx, userToBeArchived.ID)
	if err != nil {
		return nil, err
	}

	return &userToBeArchived, nil
}

// UpdateUserLanguage is the resolver for the updateUserLanguage field.
func (r *mutationResolver) UpdateUserLanguage(ctx context.Context, language db.UserLang) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	var err error
	user.User, err = r.DB.UserUpdateLanguage(ctx, db.UserUpdateLanguageParams{
		Language:       language,
		ID:             user.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &user.User, nil
}

// SendUserInvite is the resolver for the sendUserInvite field.
func (r *mutationResolver) SendUserInvite(ctx context.Context, id string) (bool, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionAdmin() {
		return false, msg.ErrUnauthorized
	}

	// try to find the user
	userToBeInvited, err := r.DB.UserFindByID(ctx, db.UserFindByIDParams{
		ID:             id,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return false, err
	}

	// set the password recovery token and send the email
	token := gonanoid.Must(32)
	_, err = r.DB.UserUpdateRecoveryToken(ctx, db.UserUpdateRecoveryTokenParams{
		RecoveryToken:  token,
		ID:             userToBeInvited.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return false, err
	}

	err = r.Services.Mail.SendInvite(userToBeInvited.Email.String, userToBeInvited.FirstName, userToBeInvited.FirstName, userToBeInvited.LanguageOrDefault(), token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateStudent is the resolver for the createStudent field.
func (r *mutationResolver) CreateStudent(ctx context.Context, input model.CreateStudentInput) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionAdmin() {
		return nil, msg.ErrUnauthorized
	}

	var createdUser db.User
	var err error
	err = r.DB.InTx(ctx, func(ctx context.Context, q *db.Queries) error {
		// create the user
		createdUser, err = q.UserCreate(ctx, db.UserCreateParams{
			Role:           db.UserRoleStudent,
			OrganisationID: user.OrganisationID,
			FirstName:      input.FirstName,
			LastName:       input.LastName,
		})
		if err != nil {
			return err
		}

		// create the student
		_, err = q.UserStudentCreate(ctx, db.UserStudentCreateParams{
			UserID:         createdUser.ID,
			OrganisationID: user.OrganisationID,
			LeftAt:         OptionalTimestamp(input.LeftAt),
			Grade:          int32(input.Grade),
			Birthday:       OptionalDate(input.Birthday),
			JoinedAt:       OptionalTimestamp(input.JoinedAt),
			Emoji:          OptionalString(input.Emoji),
		})
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return &createdUser, nil
}

// CreateUserCompetence is the resolver for the createUserCompetence field.
func (r *mutationResolver) CreateUserCompetence(ctx context.Context, input model.CreateUserCompetenceInput) (*db.UserCompetence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	// if the user is not a teacher, they can only create user competences for themselves
	if !user.HasPermissionTeacher() && user.ID != input.UserID {
		return nil, msg.ErrUnauthorized
	}

	userCompetence, err := r.DB.UserCompetenceCreateWithoutEntry(ctx, db.UserCompetenceCreateWithoutEntryParams{
		Level:          int32(input.Level),
		UserID:         input.UserID,
		CompetenceID:   input.CompetenceID,
		CreatedBy:      pgtype.Text{Valid: true, String: user.ID},
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &userCompetence, nil
}

// ArchiveUserCompetence is the resolver for the archiveUserCompetence field.
func (r *mutationResolver) ArchiveUserCompetence(ctx context.Context, id string) (*db.UserCompetence, error) {
	panic(fmt.Errorf("not implemented: ArchiveUserCompetence - archiveUserCompetence"))
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*db.Tag, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	color := input.Color
	if color == "" {
		color = "blue"
	}

	createdTag, err := r.DB.TagCreate(ctx, db.TagCreateParams{
		Name:           input.Name,
		Color:          color,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &createdTag, nil
}

// ArchiveTag is the resolver for the archiveTag field.
func (r *mutationResolver) ArchiveTag(ctx context.Context, id string) (*db.Tag, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	tag, err := r.DB.TagSoftDelete(ctx, db.TagSoftDeleteParams{
		ID:             id,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id string, input model.CreateTagInput) (*db.Tag, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	tag, err := r.DB.TagUpdate(ctx, db.TagUpdateParams{
		Name:           input.Name,
		Color:          input.Color,
		ID:             id,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &tag, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	panic(fmt.Errorf("not implemented: UpdatePassword - updatePassword"))
}

// UpdateCompetence is the resolver for the updateCompetence field.
func (r *mutationResolver) UpdateCompetence(ctx context.Context, input model.UpdateCompetenceInput) (*db.Competence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	// todo: color should be required
	if input.Color == nil {
		return nil, nil
	}

	competence, err := r.DB.CompetenceUpdateColor(ctx, db.CompetenceUpdateColorParams{
		Color:          *input.Color,
		CompetenceID:   input.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// UpdateCompetenceSorting is the resolver for the updateCompetenceSorting field.
func (r *mutationResolver) UpdateCompetenceSorting(ctx context.Context, input model.UpdateCompetenceSortingInput) ([]*db.Competence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	competences := make([]*db.Competence, len(input.Competences))
	err := r.DB.InTx(ctx, func(ctx context.Context, q *db.Queries) error {
		for i, competenceInput := range input.Competences {
			competence, err := r.DB.CompetenceUpdateSortOrder(ctx, db.CompetenceUpdateSortOrderParams{
				SortOrder:      int32(competenceInput.SortOrder),
				CompetenceID:   competenceInput.ID,
				OrganisationID: user.OrganisationID,
			})
			if err != nil {
				return err
			}

			competences[i] = &competence
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	return competences, nil
}

// CreateCompetence is the resolver for the createCompetence field.
func (r *mutationResolver) CreateCompetence(ctx context.Context, input model.CreateCompetenceInput) (*db.Competence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok || !user.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	// find subject
	subject, err := r.DB.CompetenceFindById(ctx, db.CompetenceFindByIdParams{
		ID:             input.ParentID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	defaultGrades := make([]int32, 10)
	for i := range 10 {
		defaultGrades[i] = int32(i + 1)
	}

	competence, err := r.DB.CompetenceCreate(ctx, db.CompetenceCreateParams{
		Name:           input.Name,
		CompetenceID:   pgtype.Text{Valid: true, String: subject.ID},
		CompetenceType: db.CompetenceTypeCompetence,
		OrganisationID: user.OrganisationID,
		Grades:         defaultGrades,
		CreatedBy:      pgtype.Text{Valid: true, String: user.ID},
	})
	if err != nil {
		return nil, err
	}

	return &competence, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *model.UserFilterInput, search *string) (*model.UserConnection, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	query := r.DB.NewQueryBuilder().Select("*").From("users").Where("organisation_id = ?", user.OrganisationID)
	if search != nil && *search != "" {
		query = query.Where("first_name ILIKE ? or last_name ILIKE ?", fmt.Sprintf("%%%s%%", *search), fmt.Sprintf("%%%s%%", *search))
	}

	l, o := helper.PaginationInput(limit, offset)
	query = query.Limit(l + 1).Offset(o)

	if filter != nil {
		if len(filter.Role) > 0 {
			query = query.Where("role IN (?)", filter.Role)
		}

		if filter.OrderBy != nil {
			switch *filter.OrderBy {
			case model.UserOrderByFirstNameAsc:
				query = query.OrderBy("first_name ASC")
			case model.UserOrderByFirstNameDesc:
				query = query.OrderBy("first_name DESC")
			case model.UserOrderByLastNameAsc:
				query = query.OrderBy("last_name ASC")
			case model.UserOrderByLastNameDesc:
				query = query.OrderBy("last_name DESC")
			}
		}
	}

	if filter == nil || filter.ShowDeleted == nil || !*filter.ShowDeleted {
		query = query.Where("deleted_at IS NULL")
	}

	users, err := database.ScanSelectMany[db.User](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	edges, pageInfo := helper.PaginationOutput(l, o, users)
	return &model.UserConnection{
		Edges:    lo.ToSlicePtr(edges),
		PageInfo: pageInfo,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	foundUser, err := r.DB.UserFindByID(ctx, db.UserFindByIDParams{ID: id, OrganisationID: user.OrganisationID})
	return &foundUser, err
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	return &user.User, nil
}

// Competence is the resolver for the competence field.
func (r *queryResolver) Competence(ctx context.Context, id string) (*db.Competence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	competence, err := r.DB.CompetenceFindById(ctx, db.CompetenceFindByIdParams{ID: id, OrganisationID: user.OrganisationID})

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &competence, err
}

// Competences is the resolver for the competences field.
func (r *queryResolver) Competences(ctx context.Context, limit *int, offset *int, filter *model.CompetenceFilterInput, search *string, sort *model.CompetenceSort) (*model.CompetenceConnection, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	query := r.DB.NewQueryBuilder().Select("*").From("competences").Where("organisation_id = ?", user.OrganisationID)

	// TODO: Search should use Meilisearch instead of the database
	if search != nil && *search != "" {
		query = query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", *search))
	}

	l, o := helper.PaginationInput(limit, offset)
	query = query.Limit(l + 1).Offset(o)

	if filter != nil {
		if len(filter.Type) > 0 {
			types := make([]string, len(filter.Type))
			for i, t := range filter.Type {
				types[i] = string(*t)
			}
			query = query.Where("competence_type = ANY (?)", types)
		}
		if len(filter.Parents) > 0 {
			query = query.Where("competence_id = ANY (?)", filter.Parents)
		}
	}

	if sort != nil {
		var orderBy string
		switch sort.Field {
		case model.CompetenceSortFieldCreatedAt:
			orderBy = "created_at " + string(sort.Order)
			break
		case model.CompetenceSortFieldName:
			orderBy = "name " + string(sort.Order)
			break
		case model.CompetenceSortFieldSortOrder:
			orderBy = "sort_order " + string(sort.Order)
			break
		}

		query = query.OrderBy(orderBy)
	} else {
		// Default sorting if none provided
		query = query.OrderBy("created_at DESC")
	}

	competences, err := database.ScanSelectMany[db.Competence](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	edges, pageInfo := helper.PaginationOutput(l, o, competences)
	return &model.CompetenceConnection{
		Edges:    lo.ToSlicePtr(edges),
		PageInfo: pageInfo,
	}, nil
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*db.Tag, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	tag, err := r.DB.TagFindById(ctx, db.TagFindByIdParams{
		ID:             id,
		OrganisationID: user.OrganisationID,
	})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &tag, err
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, limit *int, offset *int, search *string) (*model.TagConnection, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	query := r.DB.NewQueryBuilder().Select("*").From("tags").Where("organisation_id = ?", user.OrganisationID)

	if search != nil && *search != "" {
		query = query.Where("name ILIKE ?", fmt.Sprintf("%%%s%%", *search))
	}

	l, o := helper.PaginationInput(limit, offset)
	query = query.Limit(l + 1).Offset(o)

	// Default sorting
	query = query.OrderBy("created_at DESC")

	tags, err := database.ScanSelectMany[db.Tag](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	edges, pageInfo := helper.PaginationOutput(l, o, tags)
	return &model.TagConnection{
		Edges:    lo.ToSlicePtr(edges),
		PageInfo: pageInfo,
	}, nil
}

// UserStudents is the resolver for the userStudents field.
func (r *queryResolver) UserStudents(ctx context.Context, limit *int, offset *int) (*model.UserStudentConnection, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	query := r.DB.NewQueryBuilder().Select("*").From("user_students").Where("organisation_id = ?", user.OrganisationID)

	if !user.HasPermissionTeacher() {
		query = query.Where("user_id = ?", user.ID)
	}

	l, o := helper.PaginationInput(limit, offset)
	query = query.Limit(l + 1).Offset(o)

	userStudents, err := database.ScanSelectMany[db.UserStudent](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	edges, pageInfo := helper.PaginationOutput(l, o, userStudents)
	return &model.UserStudentConnection{
		Edges:    lo.ToSlicePtr(edges),
		PageInfo: pageInfo,
	}, nil
}

// UserStudent is the resolver for the userStudent field.
func (r *queryResolver) UserStudent(ctx context.Context, id string) (*db.UserStudent, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	// Students can only see their own user student
	if !user.HasPermissionTeacher() && user.ID != id {
		return nil, msg.ErrUnauthorized
	}

	userStudent, err := r.DB.UserStudentFindByActualUserID(ctx, db.UserStudentFindByActualUserIDParams{
		UserID:         id,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// InviteDetails is the resolver for the inviteDetails field.
func (r *queryResolver) InviteDetails(ctx context.Context, token string) (*model.InviteDetailsPayload, error) {
	// TODO: should we rate limit this?

	userDetails, err := r.DB.UserInviteDetailsByRecoveryToken(ctx, token)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	if err != nil {
		return nil, err
	}

	return &model.InviteDetailsPayload{
		Email:     userDetails.Email.String,
		FirstName: userDetails.FirstName,
		LastName:  userDetails.LastName,
	}, nil
}

// Color is the resolver for the color field.
func (r *tagResolver) Color(ctx context.Context, obj *db.Tag) (string, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return "", msg.ErrUnauthorized
	}

	tag, err := r.DB.TagFindById(ctx, db.TagFindByIdParams{
		ID:             obj.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return "blue", err
	}

	if !tag.Color.Valid {
		return "blue", errors.New("tag has no color")
	}

	return tag.Color.String, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *tagResolver) DeletedAt(ctx context.Context, obj *db.Tag) (*time.Time, error) {
	if !obj.DeletedAt.Time.IsZero() {
		return &obj.DeletedAt.Time, nil
	}
	return nil, nil
}

// Email is the resolver for the email field.
func (r *userResolver) Email(ctx context.Context, obj *db.User) (*string, error) {
	if obj.Email.Valid {
		return &obj.Email.String, nil
	}

	return nil, nil
}

// Student is the resolver for the student field.
func (r *userResolver) Student(ctx context.Context, obj *db.User) (*db.UserStudent, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	userStudent, err := r.DB.UserStudentFindByActualUserID(ctx, db.UserStudentFindByActualUserIDParams{
		UserID:         obj.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &userStudent, nil
}

// Language is the resolver for the language field.
func (r *userResolver) Language(ctx context.Context, obj *db.User) (*db.UserLang, error) {
	if obj.Language.Valid {
		return &obj.Language.UserLang, nil
	}

	return nil, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userResolver) DeletedAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	if !obj.DeletedAt.Time.IsZero() {
		return &obj.DeletedAt.Time, nil
	}
	return nil, nil
}

// InviteAccepted is the resolver for the inviteAccepted field.
func (r *userResolver) InviteAccepted(ctx context.Context, obj *db.User) (bool, error) {
	// If the password field is set, then the user accepted his invite
	if obj.Password.Valid {
		return true, nil
	}

	return false, nil
}

// LastSeenAt is the resolver for the lastSeenAt field.
func (r *userResolver) LastSeenAt(ctx context.Context, obj *db.User) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: LastSeenAt - lastSeenAt"))
}

// Competence is the resolver for the competence field.
func (r *userCompetenceResolver) Competence(ctx context.Context, obj *db.UserCompetence) (*db.Competence, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	competence, err := r.DB.CompetenceFindById(ctx, db.CompetenceFindByIdParams{
		ID:             obj.CompetenceID,
		OrganisationID: user.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &competence, err
}

// Entry is the resolver for the entry field.
func (r *userCompetenceResolver) Entry(ctx context.Context, obj *db.UserCompetence) (*db.Entry, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	if !obj.EntryID.Valid {
		return nil, nil
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             obj.EntryID.String,
		OrganisationID: user.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &entry, err
}

// User is the resolver for the user field.
func (r *userCompetenceResolver) User(ctx context.Context, obj *db.UserCompetence) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	userCompetenceUser, err := r.DB.UserFindByID(ctx, db.UserFindByIDParams{
		ID:             obj.UserID,
		OrganisationID: user.OrganisationID,
	})

	if errors.Is(err, sql.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &userCompetenceUser, err
}

// CreatedBy is the resolver for the createdBy field.
func (r *userCompetenceResolver) CreatedBy(ctx context.Context, obj *db.UserCompetence) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	if !obj.CreatedBy.Valid {
		return nil, nil
	}

	createdBy, err := r.DB.UserFindByID(ctx, db.UserFindByIDParams{
		ID:             obj.CreatedBy.String,
		OrganisationID: user.OrganisationID,
	})
	if errors.Is(err, sql.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &createdBy, err
}

// LeftAt is the resolver for the leftAt field.
func (r *userStudentResolver) LeftAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.LeftAt.Time.IsZero() {
		return &obj.LeftAt.Time, nil
	}
	return nil, nil
}

// Birthday is the resolver for the birthday field.
func (r *userStudentResolver) Birthday(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.Birthday.Time.IsZero() {
		return &obj.Birthday.Time, nil
	}

	return nil, nil
}

// Nationality is the resolver for the nationality field.
func (r *userStudentResolver) Nationality(ctx context.Context, obj *db.UserStudent) (*string, error) {
	if !obj.Nationality.Valid {
		return nil, nil
	}

	return &obj.Nationality.String, nil
}

// Comments is the resolver for the comments field.
func (r *userStudentResolver) Comments(ctx context.Context, obj *db.UserStudent) (*string, error) {
	if !obj.Comments.Valid {
		return nil, nil
	}

	return &obj.Comments.String, nil
}

// JoinedAt is the resolver for the joinedAt field.
func (r *userStudentResolver) JoinedAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.JoinedAt.Time.IsZero() {
		return &obj.JoinedAt.Time, nil
	}

	return nil, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *userStudentResolver) DeletedAt(ctx context.Context, obj *db.UserStudent) (*time.Time, error) {
	if !obj.DeletedAt.Time.IsZero() {
		return &obj.DeletedAt.Time, nil
	}

	return nil, nil
}

// EntriesCount is the resolver for the entriesCount field.
func (r *userStudentResolver) EntriesCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return 0, msg.ErrUnauthorized
	}

	count, err := r.DB.EntryUserCountByUserID(ctx, db.EntryUserCountByUserIDParams{
		UserID:         obj.UserID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// CompetencesCount is the resolver for the competencesCount field.
func (r *userStudentResolver) CompetencesCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return 0, msg.ErrUnauthorized
	}

	count, err := r.DB.UserCompetenceCountByUserID(ctx, db.UserCompetenceCountByUserIDParams{
		UserID:         obj.UserID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// EventsCount is the resolver for the eventsCount field.
func (r *userStudentResolver) EventsCount(ctx context.Context, obj *db.UserStudent) (int, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return 0, msg.ErrUnauthorized
	}

	count, err := r.DB.EntryEventCountByUserID(ctx, db.EntryEventCountByUserIDParams{
		UserID:         obj.UserID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// Emoji is the resolver for the emoji field.
func (r *userStudentResolver) Emoji(ctx context.Context, obj *db.UserStudent) (*string, error) {
	if obj.Emoji.Valid {
		return &obj.Emoji.String, nil
	}

	return nil, nil
}

// User is the resolver for the user field.
func (r *userStudentResolver) User(ctx context.Context, obj *db.UserStudent) (*db.User, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	userStudentUser, err := r.DB.UserFindByID(ctx, db.UserFindByIDParams{
		ID:             obj.UserID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &userStudentUser, nil
}

// MissedHours is the resolver for the missedHours field.
func (r *userStudentResolver) MissedHours(ctx context.Context, obj *db.UserStudent) (int, error) {
	if !obj.MissedHours.Valid {
		return 0, nil
	}

	return int(obj.MissedHours.Int32), nil
}

// MissedHoursExcused is the resolver for the missedHoursExcused field.
func (r *userStudentResolver) MissedHoursExcused(ctx context.Context, obj *db.UserStudent) (int, error) {
	if !obj.MissedHoursExcused.Valid {
		return 0, nil
	}

	return int(obj.MissedHoursExcused.Int32), nil
}

// Competence returns generated.CompetenceResolver implementation.
func (r *Resolver) Competence() generated.CompetenceResolver { return &competenceResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Tag returns generated.TagResolver implementation.
func (r *Resolver) Tag() generated.TagResolver { return &tagResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

// UserCompetence returns generated.UserCompetenceResolver implementation.
func (r *Resolver) UserCompetence() generated.UserCompetenceResolver {
	return &userCompetenceResolver{r}
}

// UserStudent returns generated.UserStudentResolver implementation.
func (r *Resolver) UserStudent() generated.UserStudentResolver { return &userStudentResolver{r} }

type competenceResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userCompetenceResolver struct{ *Resolver }
type userStudentResolver struct{ *Resolver }
