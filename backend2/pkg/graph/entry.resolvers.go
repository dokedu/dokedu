package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"fmt"
	"mime"
	"path/filepath"
	"time"

	"github.com/minio/minio-go/v7"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/samber/lo"

	"github.com/dokedu/dokedu/backend/pkg/helper"
	"github.com/dokedu/dokedu/backend/pkg/middleware"
	"github.com/dokedu/dokedu/backend/pkg/msg"
	"github.com/dokedu/dokedu/backend/pkg/services/database"

	"github.com/99designs/gqlgen/graphql"

	"github.com/dokedu/dokedu/backend/pkg/graph/generated"
	"github.com/dokedu/dokedu/backend/pkg/graph/model"
	"github.com/dokedu/dokedu/backend/pkg/services/database/db"
)

// Date is the resolver for the date field.
func (r *entryResolver) Date(ctx context.Context, obj *db.Entry) (string, error) {
	if obj.Date.Valid {
		return obj.Date.Time.String(), nil
	}
	return "", nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *entryResolver) DeletedAt(ctx context.Context, obj *db.Entry) (*time.Time, error) {
	if obj.DeletedAt.Valid {
		return &obj.DeletedAt.Time, nil
	}
	return nil, nil
}

// User is the resolver for the user field.
func (r *entryResolver) User(ctx context.Context, obj *db.Entry) (*db.User, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}
	user, err := r.DB.Loader(ctx).Users(currentUser.User).Load(ctx, obj.UserID)()
	return &user, err
}

// Users is the resolver for the users field.
func (r *entryResolver) Users(ctx context.Context, obj *db.Entry) ([]db.User, error) {
	return r.DB.UsersFindByEntryUserEntryID(ctx, db.UsersFindByEntryUserEntryIDParams{
		EntryID:        obj.ID,
		OrganisationID: obj.OrganisationID,
	})
}

// Events is the resolver for the events field.
func (r *entryResolver) Events(ctx context.Context, obj *db.Entry) ([]db.Event, error) {
	return r.DB.EventsFindByEntryEventEntryID(ctx, db.EventsFindByEntryEventEntryIDParams{
		EntryID:        obj.ID,
		OrganisationID: obj.OrganisationID,
	})
}

// Files is the resolver for the files field.
func (r *entryResolver) Files(ctx context.Context, obj *db.Entry) ([]db.File, error) {
	return r.DB.FilesFindByEntryFileEntryID(ctx, db.FilesFindByEntryFileEntryIDParams{
		EntryID:        obj.ID,
		OrganisationID: obj.OrganisationID,
	})
}

// Tags is the resolver for the tags field.
func (r *entryResolver) Tags(ctx context.Context, obj *db.Entry) ([]db.Tag, error) {
	return r.DB.TagsFindByEntryTagEntryID(ctx, db.TagsFindByEntryTagEntryIDParams{
		EntryID:        obj.ID,
		OrganisationID: obj.OrganisationID,
	})
}

// UserCompetences is the resolver for the userCompetences field.
func (r *entryResolver) UserCompetences(ctx context.Context, obj *db.Entry) ([]db.UserCompetence, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	userCompetences, err := r.DB.UserCompetenceFindByEntryID(ctx, db.UserCompetenceFindByEntryIDParams{
		EntryID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return userCompetences, nil
}

// Subjects is the resolver for the subjects field.
func (r *entryResolver) Subjects(ctx context.Context, obj *db.Entry) ([]db.Competence, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	competences, err := r.DB.CompetenceAll(ctx, currentUser.OrganisationID)
	if err != nil {
		return nil, err
	}

	userCompetences, err := r.DB.UserCompetenceFindByEntryID(ctx, db.UserCompetenceFindByEntryIDParams{
		EntryID:        obj.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	var subjects []db.Competence

	competenceMap := make(map[string]db.Competence, len(competences))
	for _, c := range competences {
		competenceMap[c.ID] = c
	}

	for _, userCompetence := range userCompetences {
		currentID := userCompetence.CompetenceID
		iterations := 0
		for {
			iterations++

			if iterations > 10_000 {
				return nil, errors.New("too many iterations")
			}

			competence, exists := competenceMap[currentID]
			if !exists || !competence.CompetenceID.Valid {
				subjects = append(subjects, competence)
				break
			}
			currentID = competence.CompetenceID.String
		}
	}

	// Ensure subjects are unique (by id)
	subjects = lo.UniqBy(subjects, func(s db.Competence) string {
		return s.ID
	})

	return subjects, nil
}

// CreateEntry is the resolver for the createEntry field.
func (r *mutationResolver) CreateEntry(ctx context.Context) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	var entry db.Entry
	entry.UserID = currentUser.ID

	entry, err := r.DB.EntryCreate(ctx, db.EntryCreateParams{
		Date:           pgtype.Date{Valid: true, Time: time.Now()},
		Body:           "",
		UserID:         currentUser.ID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// UpdateEntry is the resolver for the updateEntry field.
func (r *mutationResolver) UpdateEntry(ctx context.Context, input model.UpdateEntryInput) (*db.Entry, error) {
	user, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.ID,
		OrganisationID: user.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// students can only update their own entry, teachers can update any entry
	if !user.HasPermissionTeacher() && entry.UserID != user.ID {
		return nil, msg.ErrUnauthorized
	}

	params := db.EntryUpdateParams{
		ID:             input.ID,
		OrganisationID: user.OrganisationID,
	}

	if input.Date != nil {
		parsedDate, err := time.Parse("2006-01-02", *input.Date)
		if err != nil {
			return nil, err
		}
		params.Date = OptionalDate(lo.ToPtr(parsedDate))
		params.SetDate = true
	}
	if input.Body != nil {
		params.Body = *input.Body
		params.SetBody = true
	}

	entry, err = r.DB.EntryUpdate(ctx, params)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	return &entry, nil
}

// ArchiveEntry is the resolver for the archiveEntry field.
func (r *mutationResolver) ArchiveEntry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// students can only archive their own entry, teachers can archive any entry
	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	entry, err = r.DB.EntrySoftDelete(ctx, db.EntrySoftDeleteParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, msg.ErrNotFound
	}
	return &entry, err
}

// CreateEntryTag is the resolver for the createEntryTag field.
func (r *mutationResolver) CreateEntryTag(ctx context.Context, input model.CreateEntryTagInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// students can only create entry tags for their own entry, teachers can create entry tags for any entry
	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	_, err = r.DB.EntryTagCreate(ctx, db.EntryTagCreateParams{
		EntryID:        input.EntryID,
		TagID:          input.TagID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// CreateEntryFile is the resolver for the createEntryFile field.
func (r *mutationResolver) CreateEntryFile(ctx context.Context, input model.CreateEntryFileInput) (*db.Entry, error) {
	panic(fmt.Errorf("not implemented: CreateEntryFile - createEntryFile"))
}

// CreateEntryUser is the resolver for the createEntryUser field.
func (r *mutationResolver) CreateEntryUser(ctx context.Context, input model.CreateEntryUserInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	if !currentUser.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	// TODO: ensure the user_competences for that entry are updated (ie. a competence is added for the user for each existing competence of the entry)

	_, err := r.DB.EntryUserCreate(ctx, db.EntryUserCreateParams{
		EntryID:        input.EntryID,
		UserID:         input.UserID,
		OrganisationID: currentUser.OrganisationID,
	})

	if err != nil {
		return nil, err
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	return &entry, err
}

// CreateEntryEvent is the resolver for the createEntryEvent field.
func (r *mutationResolver) CreateEntryEvent(ctx context.Context, input model.CreateEntryEventInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	// students can only create entry events for their own entry, teachers can create entry events for any entry
	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	_, err = r.DB.EntryEventCreate(ctx, db.EntryEventCreateParams{
		EntryID:        input.EntryID,
		EventID:        input.EventID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// CreateEntryCompetence is the resolver for the createEntryCompetence field.
func (r *mutationResolver) CreateEntryCompetence(ctx context.Context, input model.CreateEntryCompetenceInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	err = r.DB.InTx(ctx, func(ctx context.Context, q *db.Queries) error {
		entryUsers, err := r.DB.UserFindByUserEntry(ctx, db.UserFindByUserEntryParams{
			EntryID:        input.EntryID,
			OrganisationID: currentUser.OrganisationID,
		})

		// TODO: turn this into a single sql query
		for _, entryUser := range entryUsers {
			_, err = r.DB.UserCompetenceCreate(ctx, db.UserCompetenceCreateParams{
				UserID:         entryUser.ID,
				CompetenceID:   input.CompetenceID,
				EntryID:        pgtype.Text{Valid: true, String: input.EntryID},
				Level:          1,
				OrganisationID: currentUser.OrganisationID,
				CreatedBy:      pgtype.Text{Valid: true, String: currentUser.ID},
			})
			if err != nil {
				return err
			}
		}

		return nil
	})

	return &entry, err
}

// DeleteEntryTag is the resolver for the deleteEntryTag field.
func (r *mutationResolver) DeleteEntryTag(ctx context.Context, input model.DeleteEntryTagInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	_, err = r.DB.EntryTagSoftDelete(ctx, db.EntryTagSoftDeleteParams{
		EntryID:        input.EntryID,
		TagID:          input.TagID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// DeleteEntryFile is the resolver for the deleteEntryFile field.
func (r *mutationResolver) DeleteEntryFile(ctx context.Context, input model.DeleteEntryFileInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	_, err := r.DB.EntryFileSoftDelete(ctx, db.EntryFileSoftDeleteParams{
		EntryID:        input.EntryID,
		FileID:         input.FileID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})

	return &entry, err
}

// DeleteEntryUser is the resolver for the deleteEntryUser field.
func (r *mutationResolver) DeleteEntryUser(ctx context.Context, input model.DeleteEntryUserInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	if !currentUser.HasPermissionTeacher() {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	err = r.DB.InTx(ctx, func(ctx context.Context, q *db.Queries) error {
		_, err := r.DB.EntryUserSoftDelete(ctx, db.EntryUserSoftDeleteParams{
			EntryID:        input.EntryID,
			UserID:         input.UserID,
			OrganisationID: currentUser.OrganisationID,
		})
		if err != nil {
			return err
		}

		// remove user competences for this entry for this user
		_, err = r.DB.UserCompetenceSoftDeleteByUserAndEntry(ctx, db.UserCompetenceSoftDeleteByUserAndEntryParams{
			UserID:         input.UserID,
			EntryID:        input.EntryID,
			OrganisationID: currentUser.OrganisationID,
		})
		return nil
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// DeleteEntryEvent is the resolver for the deleteEntryEvent field.
func (r *mutationResolver) DeleteEntryEvent(ctx context.Context, input model.DeleteEntryEventInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	_, err = r.DB.EntryEventSoftDelete(ctx, db.EntryEventSoftDeleteParams{
		EntryID:        input.EntryID,
		EventID:        input.EventID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// DeleteEntryCompetence is the resolver for the deleteEntryCompetence field.
func (r *mutationResolver) DeleteEntryCompetence(ctx context.Context, input model.DeleteEntryCompetenceInput) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	_, err = r.DB.UserCompetenceSoftDeleteByCompetenceAndEntry(ctx, db.UserCompetenceSoftDeleteByCompetenceAndEntryParams{
		EntryID:        input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// UpdateEntryUserCompetenceLevel is the resolver for the updateEntryUserCompetenceLevel field.
func (r *mutationResolver) UpdateEntryUserCompetenceLevel(ctx context.Context, input model.UpdateEntryUserCompetenceLevel) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             input.EntryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	_, err = r.DB.UserCompetenceUpdateLevels(ctx, db.UserCompetenceUpdateLevelsParams{
		Level:          int32(input.Level),
		EntryID:        input.EntryID,
		OrganisationID: currentUser.OrganisationID,
		CompetenceID:   input.CompetenceID,
	})
	if err != nil {
		return nil, err
	}

	return &entry, err
}

// UploadFileToEntry is the resolver for the uploadFileToEntry field.
func (r *mutationResolver) UploadFileToEntry(ctx context.Context, entryID string, file graphql.Upload) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             entryID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	var bucket db.Bucket

	bucket, err = r.DB.BucketForEntryFiles(ctx, currentUser.OrganisationID)
	if errors.Is(err, pgx.ErrNoRows) {
		bucket, err = r.DB.BucketForEntryFilesCreate(ctx, currentUser.OrganisationID)
		if err != nil {
			return nil, err
		}
	}
	if err != nil {
		return nil, err
	}

	fileParams := db.FileCreateParams{
		Name:           file.Filename,
		FileType:       db.FileTypeBlob,
		MimeType:       pgtype.Text{String: mime.TypeByExtension(filepath.Ext(file.Filename)), Valid: true},
		Size:           file.Size,
		BucketID:       bucket.ID,
		OrganisationID: currentUser.OrganisationID,
	}

	err = r.DB.InTx(ctx, func(ctx context.Context, q *db.Queries) error {
		fileCreated, err2 := r.DB.FileCreate(ctx, fileParams)
		if err2 != nil {
			return err2
		}

		entryFileParams := db.EntryFileCreateParams{
			EntryID:        entry.ID,
			FileID:         fileCreated.ID,
			OrganisationID: currentUser.OrganisationID,
		}

		_, err2 = r.DB.EntryFileCreate(ctx, entryFileParams)
		if err2 != nil {
			return err2
		}

		_, err2 = r.Services.Minio.PutObject(ctx, bucket.ID, fileCreated.ID, file.File, fileCreated.Size, minio.PutObjectOptions{
			ContentType: file.ContentType,
		})
		if err2 != nil {
			return errors.New("failed to upload file")
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// RemoveFileFromEntry is the resolver for the removeFileFromEntry field.
func (r *mutationResolver) RemoveFileFromEntry(ctx context.Context, entryID string, fileID string) (*db.File, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	_, err := r.DB.EntryFileSoftDelete(ctx, db.EntryFileSoftDeleteParams{
		EntryID:        entryID,
		FileID:         fileID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	file, err := r.DB.FileByID(ctx, db.FileByIDParams{
		ID:             fileID,
		OrganisationID: currentUser.OrganisationID,
	})
	if err != nil {
		return nil, err
	}

	return &file, nil
}

// Entry is the resolver for the entry field.
func (r *queryResolver) Entry(ctx context.Context, id string) (*db.Entry, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	entry, err := r.DB.EntryFindById(ctx, db.EntryFindByIdParams{
		ID:             id,
		OrganisationID: currentUser.OrganisationID,
	})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, msg.ErrNotFound
	}

	if !currentUser.HasPermissionTeacher() && entry.UserID != currentUser.ID {
		return nil, msg.ErrUnauthorized
	}

	return &entry, err
}

// Entries is the resolver for the entries field.
func (r *queryResolver) Entries(ctx context.Context, limit *int, offset *int, filter *model.EntryFilterInput, sortBy *model.EntrySortBy, search *string) (*model.EntryConnection, error) {
	currentUser, ok := middleware.GetUser(ctx)
	if !ok {
		return nil, msg.ErrUnauthorized
	}

	l, o := helper.PaginationInput(limit, offset)
	query := r.DB.NewQueryBuilder().Select("entries.*").From("entries").Where("entries.organisation_id = ?", currentUser.OrganisationID).Limit(l + 1).Offset(o)
	query = query.Where("entries.deleted_at IS NULL")

	if !currentUser.HasPermissionTeacher() {
		query = query.Where("entries.user_id = ?", currentUser.ID)
	}

	if filter != nil {
		if currentUser.HasPermissionTeacher() {
			if filter.Users != nil && len(filter.Users) > 0 {
				query = query.Join("entry_users ON entry_users.entry_id = entries.id")
				query = query.Where("entry_users.user_id = ANY (?)", filter.Users)
			}

			if filter.Authors != nil && len(filter.Authors) > 0 {
				query = query.Where("entries.user_id = ANY (?)", filter.Authors)
			}
		}
		if filter.Tags != nil && len(filter.Tags) > 0 {
			query = query.Join("entry_tags", "entry_tags.entry_id = entries.id")
			query = query.Where("entry_tags.tag_id = ANY (?)", filter.Tags)
		}
	}

	if sortBy != nil {
		switch *sortBy {
		case model.EntrySortByCreatedAtAsc:
			query = query.OrderBy("entries.created_at ASC")
		case model.EntrySortByCreatedAtDesc:
			query = query.OrderBy("entries.created_at DESC")
		case model.EntrySortByDateAsc:
			query = query.OrderBy("entries.date ASC")
		case model.EntrySortByDateDesc:
			query = query.OrderBy("entries.date DESC")
		default:
			query = query.OrderBy("entries.created_at DESC")
		}
	} else {
		query = query.OrderBy("entries.created_at DESC")
	}

	if search != nil && *search != "" {
		query = query.Where("body ILIKE ?", fmt.Sprintf("%%%s%%", *search))
	}

	entries, err := database.ScanSelectMany[db.Entry](r.DB, ctx, query)
	if err != nil {
		return nil, err
	}

	edges, pageInfo := helper.PaginationOutput(l, o, entries)
	return &model.EntryConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: 0,
	}, nil
}

// Entry returns generated.EntryResolver implementation.
func (r *Resolver) Entry() generated.EntryResolver { return &entryResolver{r} }

type entryResolver struct{ *Resolver }
