// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: bucket.sql

package db

import (
	"context"
)

const bucketForEntryFiles = `-- name: BucketForEntryFiles :one
SELECT id, name, shared, organisation_id, created_at, deleted_at, user_id
FROM buckets
WHERE name = 'entries'
  AND shared = FALSE
  AND user_id IS NULL
  AND organisation_id = $1
LIMIT 1
`

func (q *Queries) BucketForEntryFiles(ctx context.Context, organisationID string) (Bucket, error) {
	row := q.db.QueryRow(ctx, bucketForEntryFiles, organisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}

const bucketForEntryFilesCreate = `-- name: BucketForEntryFilesCreate :one
INSERT INTO buckets (name, shared, organisation_id)
VALUES ('entries', FALSE, $1)
ON CONFLICT (name, shared, organisation_id) DO UPDATE SET deleted_at = NULL
RETURNING id, name, shared, organisation_id, created_at, deleted_at, user_id
`

func (q *Queries) BucketForEntryFilesCreate(ctx context.Context, organisationID string) (Bucket, error) {
	row := q.db.QueryRow(ctx, bucketForEntryFilesCreate, organisationID)
	var i Bucket
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Shared,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UserID,
	)
	return i, err
}
