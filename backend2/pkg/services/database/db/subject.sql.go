// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: subject.sql

package db

import (
	"context"
)

const subjectCreate = `-- name: SubjectCreate :one
insert into subjects (name, organisation_id)
values ($1, $2::text)
returning id, name, organisation_id, created_at, deleted_at
`

type SubjectCreateParams struct {
	Name           string `db:"name"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) SubjectCreate(ctx context.Context, arg SubjectCreateParams) (Subject, error) {
	row := q.db.QueryRow(ctx, subjectCreate, arg.Name, arg.OrganisationID)
	var i Subject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const subjectFindByID = `-- name: SubjectFindByID :one
select id, name, organisation_id, created_at, deleted_at
from subjects
where id = $1
  and organisation_id = $2::text
  and deleted_at is null
`

type SubjectFindByIDParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) SubjectFindByID(ctx context.Context, arg SubjectFindByIDParams) (Subject, error) {
	row := q.db.QueryRow(ctx, subjectFindByID, arg.ID, arg.OrganisationID)
	var i Subject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const subjectSoftDelete = `-- name: SubjectSoftDelete :one
update subjects
set deleted_at = now()
where id = $1
  and organisation_id = $2::text
returning id, name, organisation_id, created_at, deleted_at
`

type SubjectSoftDeleteParams struct {
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) SubjectSoftDelete(ctx context.Context, arg SubjectSoftDeleteParams) (Subject, error) {
	row := q.db.QueryRow(ctx, subjectSoftDelete, arg.ID, arg.OrganisationID)
	var i Subject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const subjectUpdate = `-- name: SubjectUpdate :one
update subjects
set name = $1
where id = $2
  and organisation_id = $3::text
returning id, name, organisation_id, created_at, deleted_at
`

type SubjectUpdateParams struct {
	Name           string `db:"name"`
	ID             string `db:"id"`
	OrganisationID string `db:"organisation_id"`
}

func (q *Queries) SubjectUpdate(ctx context.Context, arg SubjectUpdateParams) (Subject, error) {
	row := q.db.QueryRow(ctx, subjectUpdate, arg.Name, arg.ID, arg.OrganisationID)
	var i Subject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const subjectsAllPaginated = `-- name: SubjectsAllPaginated :many
select id, name, organisation_id, created_at, deleted_at
from subjects
where organisation_id = $1::text
  and deleted_at is null
order by name
limit $3 offset $2
`

type SubjectsAllPaginatedParams struct {
	OrganisationID string `db:"organisation_id"`
	Offset         int32  `db:"_offset"`
	Limit          int32  `db:"_limit"`
}

func (q *Queries) SubjectsAllPaginated(ctx context.Context, arg SubjectsAllPaginatedParams) ([]Subject, error) {
	rows, err := q.db.Query(ctx, subjectsAllPaginated, arg.OrganisationID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const subjectsFindByID = `-- name: SubjectsFindByID :many
select id, name, organisation_id, created_at, deleted_at
from subjects
where id = any($1::text[])
  and organisation_id = $2::text
  and deleted_at is null
`

type SubjectsFindByIDParams struct {
	Ids            []string `db:"ids"`
	OrganisationID string   `db:"organisation_id"`
}

func (q *Queries) SubjectsFindByID(ctx context.Context, arg SubjectsFindByIDParams) ([]Subject, error) {
	rows, err := q.db.Query(ctx, subjectsFindByID, arg.Ids, arg.OrganisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subject
	for rows.Next() {
		var i Subject
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
